<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (13)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (13)</h1>

<p class="perex">Na øadì je dal¹í vstupní zaøízení, tentokrát se jedná o my¹. Opìt se budeme vìnovat, jak událostem, tak pøímému pøístupu.</p>


<h2>Stisk tlaèítka my¹i</h2>

<p>V¾dy, kdy¾ u¾ivatel stiskne nìkteré tlaèítko my¹i, vygeneruje SDL dvì události - SDL_MOUSEBUTTONDOWN a SDL_MOUSEBUTTONUP. První z nich je odeslána pøi stisku a druhá pøi uvolnìní. V obou pøípadech se podrobnosti o události hledají v podobjektu event.button, který byl odvozen ze struktury SDL_MouseButtonEvent.</p>

<pre>
typedef struct
{
	Uint8 type;
	Uint8 button;
	Uint8 state;
	Uint16 x, y;
} SDL_MouseButtonEvent;
</pre>

<p>Atribut type je klasicky nastaven na jméno události a promìnná button ukládá jméno tlaèítka, co¾ je jedna ze symbolických konstant SDL_BUTTON_LEFT, SDL_BUTTON_MIDDLE a SDL_BUTTON_RIGHT. Ve verzi 1.2.5 SDL dále pøibyla jména SDL_BUTTON_WHEELUP a SDL_BUTTON_WHEELDOWN, jen¾ oznamují toèení rolovacím koleèkem nahoru a dolù.</p>

<p>Stejnì jako u klávesnice, i zde mù¾e být state nastaveno na SDL_PRESSED nebo SDL_RELEASED, tuto informaci v¹ak u¾ máme k dispozici z parametru type. Promìnné x a y poskytují pozici my¹i v klientské oblasti okna pøi stisku, bod [0, 0] se nachází v levém horním rohu.</p>

<p>V následujícím pøíkladu program zachytává stisk levého tlaèítka my¹i a jako reakci vypí¹e do konzole informaci o pozici v oknì.</p>

<pre>
// O¹etøení událostí
case SDL_MOUSEBUTTONDOWN:
	switch(event.button.button)
	{
	case SDL_BUTTON_LEFT:
		printf("BUTTON_LEFT - pos(%d,%d)\n",
				event.button.x,
				event.button.y);
		fflush(stdout);
		break;

	default:
		break;
	}
	break;
</pre>

<p>Výstup programu po dvou stisknutích levého tlaèítka:</p>

<pre>
BUTTON_LEFT - pos(65,103)
BUTTON_LEFT - pos(91,104)
</pre>


<h2>Událost pohybu my¹í</h2>

<p>Pohyb my¹í oznamuje SDL zprávou SDL_MOUSEMOTION, podrobnosti se následnì hledají v objektu event.motion odvozeného od SDL_MouseMotionEvent.</p>

<pre>
typedef struct
{
	Uint8 type;
	Uint8 state;
	Uint16 x, y;
	Sint16 xrel, yrel;
} SDL_MouseMotionEvent;
</pre>

<p>Promìnná state definuje stavy tlaèítek pøi pohybu. Pro zji¹tìní, které je stisknuté a které ne, mù¾e být výhodné pou¾ít makro SDL_BUTTON(). Parametry x a y specifikují pozici kurzoru my¹i v oknì, xrel a yrel obsahují relativní hodnotu posunu.</p>

<p>Po pøíchodu události o pohybu my¹i v pøíkladu ní¾e, vypí¹e program absolutní polohu kurzoru v oknì, zmìnu polohy od minula a pøípadnì informaci o stisku tlaèítek.</p>

<pre>
// O¹etøení událostí
case SDL_MOUSEMOTION:
	printf("MOUSEMOTION - pos(%d,%d), relpos(%d,%d)%s%s%s\n",
		event.motion.x, event.motion.y,
		event.motion.xrel, event.motion.yrel,
		(event.motion.state &amp; SDL_BUTTON(SDL_BUTTON_LEFT))
				? ", left" : "",
		(event.motion.state &amp; SDL_BUTTON(SDL_BUTTON_MIDDLE))
				? ", middle" : "",
		(event.motion.state &amp; SDL_BUTTON(SDL_BUTTON_RIGHT))
				? ", right" : "");
	fflush(stdout);
	break;
</pre>

<p>Pokud je program spu¹tìn, zaènou se pøi pohybování my¹í generovat výpisy podobné následujícím.</p>

<pre>
MOUSEMOTION - pos(130,91), relpos(4,0)
MOUSEMOTION - pos(134,91), relpos(4,0)
MOUSEMOTION - pos(138,91), relpos(4,0)
MOUSEMOTION - pos(136,91), relpos(-2,0), left
MOUSEMOTION - pos(132,93), relpos(-4,2), left, right
MOUSEMOTION - pos(130,93), relpos(-2,0), left, right
MOUSEMOTION - pos(128,95), relpos(-2,2), left, right
</pre>


<h2>&quot;Pøímý&quot; pøístup k my¹i</h2>

<p>Stejnì jako u klávesnice, i u my¹i je mo¾né pou¾ívat metody pøímého pøístupu. Lze se tedy kdekoli v programu dotázat na aktuální polohu kurzoru nebo stisk tlaèítek.</p>

<pre>
Uint8 SDL_GetMouseState(int *x, int *y);
</pre>

<p>Tato funkce ulo¾í na adresu ukazatelù v parametrech aktuální polohu my¹i v oknì a vrátí bitové pole tlaèítkových flagù. Pro rozli¹ení, které je stisknuté a které ne, je opìt nejjednodu¹¹í pou¾ít bitový souèin s makrem SDL_BUTTON(). Pokud nás zajímají pouze tlaèítka, je mo¾né pøedat do parametrù hodnoty NULL.</p>

<p>Pøed samotným pøístupem k my¹i bývá vhodné zavolat funkci SDL_PumpEvents(), která aktualizuje informace v SDL.</p>

<p>Podobným zpùsobem se lze dotazovat i na relativní zmìny polohy od minulého volání této funkce nebo od zpracování události o pohybu my¹i.</p>

<pre>
Uint8 SDL_GetRelativeMouseState(int *x, int *y);
</pre>

<p>Do promìnných x a y bude v pøíkladu ní¾e ulo¾ena aktuální poloha my¹i, kód v sekci if se provede jen tehdy, je-li stisknuto levé tlaèítko.</p>

<pre>
// Kdekoli v programu
int x, y;

SDL_PumpEvents();
if(SDL_GetMouseState(&amp;x, &amp;y) &amp; SDL_BUTTON(SDL_BUTTON_LEFT))
	printf("Levé tlaèítko na %d, %d.\n", x, y);
</pre>


<h2>Ruèní zmìna polohy my¹i</h2>

<p>Novou polohu my¹i lze specifikovat voláním funkce SDL_WarpMouse(), do parametrù se pøedávají po¾adované x a y souøadnice.</p>

<pre>
void SDL_WarpMouse(Uint16 x, Uint16 y);
</pre>

<p>Tato funkce má jeden vedlej¹í efekt, zpùsobuje generování události SDL_MOUSEMOTION, co¾ mù¾e být nìkdy, kvùli zacyklení, ne¾ádoucí (v reakci na událost se o¹etøí zmìna polohy a my¹ se pøesune na nové místo, tím se generuje dal¹í událost, která se opìt o¹etøí, my¹ se pøesune atd.). Asi nejjednodu¹¹í øe¹ení spoèívá v ignorování této &quot;pøebyteèné&quot; události.</p>

<p>Pøi zmìnách natoèení kamery ve 3D akèních hrách konèí o¹etøení ka¾dého pohybu my¹i nastavením její polohy zpìt na støed okna. Je to z dùvodu, ¾e kdyby opustila okno, mohlo by ztratit fokus (vìt¹inou po kliknutí na jiné okno pøi støelbì) a operaèní systém by v takovém pøípadì pøestal posílat zprávy. Hra by se ka¾dou chvíli stávala nehratelnou.</p>

<p>Implementace rotace kamery v závislosti na pohybech my¹i by mohla vypadat následovnì.</p>

<pre>
// O¹etøení událostí
case SDL_MOUSEMOTION:
	// SDL_WarpMouse() generuje SDL_MOUSEMOTION,
	// bez testu na støed okna by se aplikace zacyklila
	if(event.motion.x != GetWinWidth() >> 1
		|| event.motion.y != GetWinHeight() >> 1)
	{
		m_cam.Rotate(event.motion.xrel,
			event.motion.yrel, GetFPS());

		// Pøesun zpìt doprostøed okna
		SDL_WarpMouse(GetWinWidth() >> 1,
			GetWinHeight() >> 1);
	}
	break;
</pre>

<p>V¹imnìte si pøedev¹ím ignorování událostí, které generuje funkce SDL_WarpMouse(). Mimochodem, tento kód jsme pou¾ili v pøíkladu Pohyb v møí¾ce z <a href="sdl_08.html">osmého dílu</a>. Jedná se o metodu QGridApp::ProcessEvent(SDL_Event&amp; event).</p>

<p>Dal¹í mo¾ností by mohl být zákaz pro my¹ opustit okno aplikace, zbavili bychom se tak neustálého mìnìní její polohy a následného rozli¹ování validity událostí. V SDL staèí zavolat funkci SDL_WM_GrabInput() s parametrem SDL_GRAB_ON (popsána v <a href="sdl_10.html">desátém dílu</a>), v nìkterých jiných knihovnách v¹ak takové vymo¾enosti nejsou.</p>


<h2>Barevné kurzory</h2>

<p>Je¹tì jedna specialitka na závìr. V <a href="sdl_07.html">sedmém dílu</a> jsme si ukázali, jak po¾ádat SDL, aby zmìnilo kurzor my¹i ze standardní ¹ipky na jiný. Tato technika v¹ak mìla tu nevýhodu, ¾e kurzor mohl být pouze èernobílý.</p>

<p>V tuto chvíli v¹ak u¾ máme dostatek znalostí, abychom standardní kurzor my¹i vypnuli a vykreslovali si vlastní, na nìj¾ u¾ nejsou kladena ¾ádná omezení.</p>

<pre>
// Pro vycentrování obrázku na aktivní bod kurzoru
// U ¹ipek levý horní roh, u zamìøovaèù støed, apod.
#define POSUN_DOLEVA 0
#define POSUN_NAHORU 0

// Inicializace, skryje kurzor
SDL_ShowCursor(0);

// Vykreslování (kurzor by se mìl v¾dy kreslit jako poslední)
SDL_Rect rect;

SDL_GetMouseState(&amp;rect.x, &amp;rect.y);
rect.x -= POSUN_DOLEVA;
rect.y -= POSUN_NAHORU;

SDL_BlitSurface(g_cur_press, NULL, g_screen, &amp;rect);
</pre>

<p>Tento kód pøedpokládá, ¾e se scéna periodicky pøekresluje, nejlépe v &quot;klasické&quot; herní smyèce nebo v reakci na pohyb my¹i a poka¾dé se kreslí úplnì v¹echno.</p>


<h2>Ukázkové programy</h2>

<h3>Kostky</h3>

<p>Program zobrazuje v dolní èásti okna spoustu kostièek, které lze kliknutím my¹i zachytit a následnì s nimi pohybovat. Jsou implementovány i kolize a také vlastní barevný kurzor, jen¾ se po kliknutí na nìjakou kostku zmìní na jiný. <a href="./src/sdl_13_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/13_prog_a.png" width="322" height="259" alt="Kostky" /></div>


<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_13_a.tar.gz">Pøíklad: Kostky</a></li>
<li><a href="sdl_13.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Minule klávesnice, teï my¹, tak¾e pøístì bude na øadì joystick...</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 24.04.2005</div>

</body>
</html>
