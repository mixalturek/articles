<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (16)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (16)</h1>

<p class="perex">V dne¹ním díle se podíváme na systémové èasovaèe a funkce pro práci s èasem. Na konci budou také v rychlosti zmínìny rychlostní optimalizace vèetnì výpoètu FPS.</p>


<h2>Systémové èasovaèe</h2>

<p>Pokud je nutné spou¹tìt nìjakou funkci s urèitou frekvencí neustále dokola, mù¾e být výhodné vyu¾ít slu¾eb systémového èasovaèe. Jedná se o mechanismus, kterým je mo¾né po¾ádat SDL, aby v¾dy po uplynutí urèitého èasu spustilo pøedem specifikovaný kód. Pøi pou¾ívání èasovaèù je nutné pøedat do funkce SDL_Init() v inicializaci symbolickou konstantu SDL_INIT_TIMER.</p>

<p>Èasovaè se aktivuje funkcí SDL_AddTimer(), její¾ první parametr definuje èasový interval v milisekundách, po jeho¾ uplynutí se spustí callback funkce, té bude pøedáván poslední parametr. Návratovou hodnotou je ID právì vytvoøeného timeru nebo NULL v pøípadì chyby.</p>

<pre>
SDL_TimerID SDL_AddTimer(Uint32 interval,
		SDL_NewTimerCallback callback,
		void *param);
</pre>

<p>Identifikátor SDL_NewTimerCallback je definován jako ukazatel na funkci se dvìma parametry, která vrací Uint32.</p>

<pre>
typedef Uint32 (*SDL_NewTimerCallback)(Uint32 interval, void *param);
</pre>

<p>Spu¹tìný èasovaè se dá zastavit funkcí SDL_RemoveTimer(), pøedává se mu jeho ID. Minimálnì pøi ukonèování programu mù¾e být zavolání dobrým nápadem...</p>

<pre>
SDL_bool SDL_RemoveTimer(SDL_TimerID id);
</pre>

<p>Vzhledem k tomu, ¾e zvlá¹tì zaèínající programátoøi mívají s ukazateli na funkce mnoho problémù, následuje kompletní ukázka kódu, který je potøeba pro zprovoznìní timeru napsat. Definuje se globální promìnná ukládající ID vytváøené timeru, napí¹e se callback funkce a ukazatel na ni se pøedá spolu s libovolným parametrem do SDL_AddTimer(). Pokud nevznikne ¾ádný problém, bude se tato funkce opakovanì volat s periodou cca. jedné sekundy (1000 milisekund). Na konci se timer zastaví.</p>

<pre>
// Globální
SDL_TimerID g_timer_id = NULL;

Uint32 Callback(Uint32 interval, void* param)
{
	// U¾ivatelský kód

	return interval;
}

// Spu¹tìní èasovaèe (napø. inicializace)
	g_timer_id = SDL_AddTimer(1000, Callback, NULL);

// Zastavení èasovaèe (napø. deinicializace)
	SDL_RemoveTimer(g_timer_id);
</pre>

<p>Jak jste si jistì v¹imli, callback funkci je pøedávána hodnota zpo¾dìní pøed spu¹tìním. Aby se docílilo periodického volání, musí být jejím výstupem interval pro pøí¹tì. Ten mù¾e být buï stejný jako pøede¹lý (vìt¹inou return interval; - viz pøíklad vý¹e), nebo libovolný jiný.</p>

<p>V pøípadì, ¾e se pøedchozí interval s právì specifikovaným èasem neshodují, SDL aktuální èasovaè zastaví a spustí nový s novou èasovou konstantou. V¹e se v¹ak dìje na pozadí, tak¾e se jako programátoøi nemusíme o nic starat, staèí jen vrátit rozdílnou hodnotu.</p>

<p>Jeliko¾ mù¾e být callback funkce provádìna v jiném vláknu, ne¾ bì¾í zbytek programu, mìla by spou¹tìt výhradnì thread-safe funkce (problematika vícevláknového programování bude vysvìtlena v následujících dílech). Nejpohodlnìj¹ím øe¹ením mù¾e být vygenerování u¾ivatelské události, na ní¾ pak zareaguje sama aplikace.</p>

<p>Pozn.: Èasová pøesnost timerù je závislá na platformì, v¾dy by se mìlo poèítat s urèitou nepøesností. Co vím, tak u Win9x se udávalo cca. 55 ms a u Windows na bázi NT nìco málo pøes 10 ms. Jedná se v¹ak o minimální hodnoty, vìt¹inou bývají nepøesnosti vzhledem k zatí¾ení systému mnohem vy¹¹í.</p>

<p>Napøíklad ve zmínìných MS Windows jsou timery implementovány posíláním zprávy WM_TIMER. Problémem je, ¾e pokud se u¾ ve frontì tato událost nachází, není do ní nikdy vlo¾ena znovu. Tudí¾, kdyby aplikace kontrolovala frontu øeknìme jednou za sekundu (extrém) a timer byl nastaven na periodu 20 ms, dostávala by aplikace stále jen jednu zprávu za sekundu a ostatní by byly ignorovány.</p>


<h2>Zpo¾dìní</h2>

<p>Vykonávání programu se dá pozastavit voláním funkce SDL_Delay(), které se pøedá po¾adovaný èas v milisekundách. Tato doba bude v¹ak z technických dùvodù v¾dy o nìco del¹í.</p>

<pre>
void SDL_Delay(Uint32 ms);
</pre>

<p>Volání SDL_Delay() umo¾ní operaènímu systému pøidìlit èas CPU i ostatním procesùm, resp. program jím øíká, ¾e mu po specifikované èasové údobí nemusí pøidìlovat ¾ádný èas procesoru a má ho radìji vìnovat bìhu ostatních procesù/programù, proto¾e by stejnì nic nedìlal.</p>

<p>Pozn.: Z minulého odstavce jste jistì vytu¹ili, ¾e generovat èasové zpo¾dìní pomocí tøí vnoøených cyklù není zrovna nej¹»astnìj¹í nápad... ;-)</p>

<p>Volání této funkce s intervalem vìt¹ím ne¾, øeknìme, jedna sekunda také není moc vhodné. Program je kompletnì pozastaven a tudí¾ nereaguje na ¾ádné u¾ivatelské vstupy, nepøekresluje okno a nedìlá zkrátka vùbec nic, co dìlá v normálním re¾imu.</p>

<p>První, co napadne u¾ivatele sedícího pøed monitorem, je, ¾e se ten ***** program zase zaseknul, a v podstatì má pravdu. Tak¾e zaène chaoticky klikat na ukonèovací køí¾ek, maèkat nejrùznìj¹í klávesové zkratky a i kdy¾ byl program pozastaven zámìrnì, pøíchozí SDL_QUIT po obnovení do normálního re¾imu, popø. systémový kill, ho dozajista ukonèí.</p>


<h2>Zji¹tìní uplynulého èasu</h2>

<p>Funkce SDL_GetTicks() vrací tzv. referenèní èas, u nìho¾ nás nezajímá ani tak hodnota (v tomto pøípadì poèet milisekund od inicializace SDL), jako rozdíl hodnot ze dvou volání funkce, který se pou¾ije pro výpoèet napø. posunutí objektu v èase na novou pozici.</p>

<pre>
Uint32 SDL_GetTicks(void);
</pre>

<p>Mimochodem, pozor na pøeteèení datového typu po cca. 49 dnech, pokud je mo¾né, ¾e program pobì¾í tak dlouho.</p>

<p>SDL_GetTicks() netrpí podobným neduhem, jako funkce s analogickým urèením z nìkterých jiných knihoven. Napø. èasto pou¾ívaná GetTickCount() z Win32 API vrací &quot;konstantní&quot; hodnotu, která se v¾dy po uplynutí ~55 milisekund skokovì aktualizuje. Mimochodem, aby nevznikl flame, ve Windows je mo¾né pou¾ít tzv. Performance counter, který je výraznì pøesnìj¹í ne¾ obyèejný GetTickCount().</p>


<h2>Rychlostní optimalizace her</h2>

<p>Vìt¹ina her potøebuje nìjakým zpùsobem zajistit, aby byly v¹echny pohyby a animace stejnì rychlé na v¹ech poèítaèích, na kterých pobì¾í. Bez zpìtné vazby bude jistì rozdíl, kdy¾ se hra vyvíjená na 300 MHz poèítaèi spustí na 3 GHz systému.</p>

<p>V pøípadì, ¾e program implementuje klasickou herní smyèku, mù¾e být rozdíl hodnot ze dvou po sobì jdoucích volání vý¹e zmínìné funkce SDL_GetTicks() pou¾it pro rychlostní optimalizace. V¾dy se pracuje výhradnì s diferencí souèasného èasu a èasu prùchodu stejným místem v minulosti. Ukázka bude asi názornìj¹í.</p>

<pre>
// Globální promìnná
Uint32 g_last_time = 0;

// Hlavní smyèka programu
bool done = false;
while(!done)
{
	Uint32 dt = SDL_GetTicks() - g_last_time;

	// Zbyteènì malý interval (~100 FPS)
	if(dt &lt; 20)
	{
		// Nechá nìco i ostatním procesùm
		SDL_Delay(10);
		dt = SDL_GetTicks() - g_last_time;
	}

	g_last_time = SDL_GetTicks();

	ProcessEvent();	// Události
	Update(dt);	// Aktualizace scény
	Draw();		// Pøekreslení
}
</pre>

<p>V¹imnìte si, ¾e aktualizaèní funkci Update() se pøedává vypoètená hodnota èasové diference. Násobení zmìny pozice diferencí èasu zpùsobí, ¾e v¹echny pohyby budou pøi spu¹tìní i tøeba na desetkrát rychlej¹ím poèítaèi pro u¾ivatele v¾dy stejné.</p>

<pre>
int g_xpos, g_ypos;

void Update(Uint32 dt)
{
	g_xpos += 0.01 * dt;
	g_ypos += 0.01 * dt;
}
</pre>

<p>Jedná-li se o výkonný poèítaè, je dt nízké a pøírùstek pozice kvùli násobení men¹í, ne¾ na pomalém systému, nicménì bude aplikován èastìji. U výraznì pomalého poèítaèe budou pøírùstky vysoké, ale kvùli malé frekvenci zaène docházet k trhání pohybù. Pak existují jen dvì mo¾nosti: buï se pokusit o optimalizace programu, nebo upgrade poèítaèe.</p>


<h2>Výpoèet FPS</h2>

<p>Existují dva základní zpùsoby, jak vypoèítat poèet pøekreslení scény za sekundu (FPS). První napadne asi ka¾dého, v ka¾dém prùchodu hlavní smyèkou inkrementovat èítaè a otestovat, jestli u¾ uplynul èas jedné sekundy od zaèátku poèítání. Pokud ano, obsahuje èítaè po¾adovanou hodnotu FPS.</p>

<p>Druhou mo¾ností je pou¾ít matematiku a poèítat FPS dynamicky. Máme-li k dispozici rozdíl èasù mezi dvìma pøekresleními, staèí se zeptat kolikrát by se ve¹ly do jedné sekundy.</p>

<pre>
float fps = 1000.0f / dt;
</pre>

<p>V¾dy byste se mìli ujistit, ¾e dt neobsahuje nulu. V minulém pøíkladu by se nic vá¾ného nestalo, ale tady by do¹lo k dìlení nulou. Aktualizaèní funkce s vyu¾itím FPS bude vypadat následovnì, objekt se bude pohybovat v obou souøadnicových osách rychlostí 100 pixelù za sekundu.</p>

<pre>
int g_xpos, g_ypos;

void Update(float fps)
{
	g_xpos += 100.0f / fps;
	g_ypos += 100.0f / fps;
}
</pre>

<p>Je nutné podotknout, ¾e a» u¾ se pohyby objektù regulují pomocí fps nebo dt, výsledek bude v¾dy stejný. FPS je ale mo¾ná o nìco pøirozenìj¹í, také neøíkáte, ¾e auto ujede 0.01 metrù za x (mili)sekund, ale ¾e jeho rychlost je 100 km/h.</p>


<h2>Ukázkové programy</h2>

<h3>Systémový èasovaè</h3>

<p>Dne¹ní ukázkový program tvoøí základ pro hru ve stylu Pacmana. Na pozadí je dla¾dicovì vykreslena møí¾ka, ve které se pohybuje hráè ovládaný ¹ipkami. Pohyby jsou implementovány pomocí systémového timeru, který lze zrychlit/zpomalit klávesami +/-. <a href="./src/sdl_16_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/16_prog_a.png" width="322" height="259" alt="Systémový èasovaè" /></div>

<p>Ukázku na herní smyèku s FPS optimalizacemi lze najít napøíklad v ukázkovém pøíkladu z <a href="sdl_12.html">dvanáctého dílu</a>, ale i mnoha dal¹ích.</p>


<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_16_a.tar.gz">Pøíklad: Systémový èasovaè</a></li>
<li><a href="sdl_16.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Pøí¹tì se podíváme na práci se zvuky a hudbou.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 12.06.2005</div>

</body>
</html>
