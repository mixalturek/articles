<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (8)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (8)</h1>

<p class="perex">Díky pøímé podpoøe OpenGL umo¾òuje SDL renderovat i 3D grafické objekty, které se staly nepsaným standardem naprosté vìt¹iny dne¹ních her. Tentokrát se tedy budeme vìnovat podpoøe OpenGL v SDL.</p>


<h2>Okno s podporou OpenGL</h2>

<p>Ve ètvrtém dílu bylo ukázáno, ¾e jediným rozdílem mezi vytvoøením &quot;klasického&quot; okna a okna s podporou OpenGL je symbolická konstanta SDL_OPENGL (respektive SDL_OPENGLBLIT), která se pøi inicializaci pøedá spolu s ostatními flagy funkci SDL_SetVideoMode(). Tím bychom mohli celý èlánek skoro ukonèit, ale zbývá probrat je¹tì nìkolik vìcí...</p>


<h2>Soubory pro OpenGL</h2>

<p>SDL nabízí programátorovi hlavièkový soubor SDL_opengl.h, který za nìj vyøe¹í rùzné umístìní OpenGL souborù gl.h a glu.h v nìkterých systémech. Zároveò umo¾òuje pou¾ívat roz¹íøení (extensiony), ale nevkládá je klasicky prostøednictvím glext.h, ale jeho obsah zahrnuje pøímo v sobì.</p>

<p>Nemìlo by být zapomenuto na pøilinkování OpenGL knihoven (libGL.so, libGLU.so v Linuxu popø. opengl32.lib a glu32.lib ve Visual C++ pod MS Windows), jinak program nepùjde s odkazy na neexistující funkce vytvoøit.</p>


<h2>Atributy OpenGL kontextu</h2>

<p>Pøed samotným voláním SDL_SetVideoMode() by ji¾ mìly být specifikovány atributy definující vlastnosti OpenGL kontextu, po vytvoøení okna u¾ nepùjdou zmìnit.</p>

<pre>
int SDL_GL_SetAttribute(SDL_GLattr attr, int value);
</pre>

<p>Prvním parametrem se urèuje nastavovaný atribut a druhý parametr pøedstavuje jeho hodnotu. Za atributy lze pou¾ít nìkterou z následujících konstant.</p>


<ul>
<li class="vspace">SDL_GL_RED_SIZE, SDL_GL_GREEN_SIZE, SDL_GL_BLUE_SIZE, SDL_GL_ALPHA_SIZE<br />Velikosti jednotlivých barevných komponent ve framebufferu</li>

<li class="vspace">SDL_GL_BUFFER_SIZE<br />Velikost framebufferu v bitech</li>

<li class="vspace">SDL_GL_DOUBLEBUFFER<br />Nula vypíná OpenGL double buffering, jednièka zapíná. Tento parametr nemá nic spoleèného se SDL_DOUBLEBUF pøedávaného do SDL_SetVideoMode().</li>

<li class="vspace">SDL_GL_DEPTH_SIZE<br />Velikost bufferu hloubky</li>

<li class="vspace">SDL_GL_STENCIL_SIZE<br />Velikost stencil bufferu</li>

<li class="vspace">SDL_GL_ACCUM_RED_SIZE, SDL_GL_ACCUM_GREEN_SIZE, SDL_GL_ACCUM_BLUE_SIZE, SDL_GL_ACCUM_ALPHA_SIZE<br />Velikosti jednotlivých komponent v akumulaèním bufferu</li>

<li class="vspace">SDL_GL_STEREO<br />Stereoskopický OpenGL kontext; parametr není dostupný na v¹ech systémech</li>

<li class="vspace">SDL_GL_MULTISAMPLEBUFFERS, SDL_GL_MULTISAMPLESAMPLES<br />Zapíná fullscreenový antialiasing (fsaa) a specifikuje poèet vzorkù; do SDL pøidán ve verzi 1.2.6 a je dostupný pouze, pokud grafická karta podporuje roz¹íøení GL_ARB_multisample. Tento parametr zlep¹uje grafické vzezøení aplikace - vyhlazuje ostré hrany barevných pøechodù.</li>
</ul>

<p>Pozn.: Poslednímu parametru, fsaa, se nebudu dále vìnovat, proto¾e moje grafická karta zmínìný extension nepodporuje. Projevuje se to tak, ¾e se SDL_SetVideoMode() pøi jeho definování ukonèí s chybou a následný SDL_GetError() vrátí øetìzec &quot;Couldn't find matching GLX visual&quot;.</p>

<p>Pravdìpodobnì bude nutné vytvoøit &quot;obyèejné&quot; OpenGL okno a zeptat se gluCheckExtension(), zda je fsaa podporován. Pokud ano, zavøít okno a vytvoøit ho znovu, tentokrát s podporou fsaa, pokud ne, pokraèovat beze zmìny dále. Druhou mo¾ností je naèítat konfiguraci ze souboru a nechat jeho zapnutí na u¾ivateli.</p>

<p>Typický pøíklad nastavení OpenGL atributù</p>

<pre>
// Umístit PØED volání SDL_SetVideoMode()
SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);	// Doublebuffering ano
SDL_GL_SetAttribute(SDL_GL_BUFFER_SIZE, 24);	// 24 bitový framebuffer
SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);	// 24 bitový depth buffer

SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 0);	// ®ádný stencil buffer
SDL_GL_SetAttribute(SDL_GL_ACCUM_RED_SIZE, 0);	// ®ádný akumulaèní buffer
SDL_GL_SetAttribute(SDL_GL_ACCUM_GREEN_SIZE, 0);
SDL_GL_SetAttribute(SDL_GL_ACCUM_BLUE_SIZE, 0);
SDL_GL_SetAttribute(SDL_GL_ACCUM_ALPHA_SIZE, 0);

// Pouze pokud grafická karta podporuje GL_ARB_multisample
// SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);// FSAA ano
// SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 2);// 2 vzorky
</pre>


<h2>Zji¹tìní atributù</h2>

<p>Nìkdy mù¾e být dobré po vytvoøení okna zjistit, zda byl, nebo nebyl atribut nastaven. Slou¾í k tomu funkce SDL_GL_GetAttribute().</p>

<pre>
int SDL_GL_GetAttribute(SDLGLattr attr, int *value);
</pre>

<p>Stejnì jako SDL_GL_SetAttribute() i tato funkce vrací pøi úspìchu 0 a pøi neúspìchu -1, ale mìla by být volána a¾ po SDL_SetVideoMode(). Hodnota zji¹»ovaného atributu bude ulo¾ena na adresu value.</p>

<p>Pøíklad na zji¹tìní velikosti hloubkového bufferu:</p>

<pre>
// Umístit ZA volání SDL_SetVideoMode()
int tmp;
SDL_GL_GetAttribute(SDL_GL_DEPTH_SIZE, &tmp);

printf("Velikost hloubkového bufferu je %d bitù\n.", tmp);
</pre>


<h2>Prohození vykreslovacích bufferù</h2>

<p>K prohození pøedního a zadního bufferu po renderingu scény slou¾í v SDL funkce SDL_GL_SwapBuffers(), bez jejího volání by se nikdy nic nezobrazilo.</p>

<pre>
void SDL_GL_SwapBuffers(void);
</pre>

<p>Pokud byla pøi vytváøení okna definována mo¾nost pou¾ití i klasické SDL grafiky (SDL_OPENGLBLIT), je nutné volat navíc i SDL_UpdateRects().</p>


<h2>Získání adresy OpenGL funkce</h2>

<p>Ukazatel na jakoukoli OpenGL rutinu (vìt¹inou se jedná o roz¹íøení) lze získat pomocí funkce</p>

<pre>
void *SDL_GL_GetProcAddress(const char* proc);
</pre>

<p>Parametrem je øetìzec se jménem funkce a návratovou hodnotou daný ukazatel. Pokud nebude funkce nalezena je vráceno NULL.</p>


<h2>Specifikace OpenGL knihovny</h2>

<p>SDL se v bì¾ném pøípadì linkuje s OpenGL knihovnou, která se nachází v systému, ale pokud programátor chce, mù¾e být SDL zkompilováno, aby nahrávalo OpenGL ovladaè v runtimu (standardnì vypnuto).</p>

<pre>
int SDL_GL_LoadLibrary(const char *path);
</pre>

<p>Tato funkce musí být opìt volána je¹tì pøed SDL_SetVideoMode(), parametr specifikuje diskovou cesta k OpenGL knihovnì. Pokud se ji podaøí nahrát, je vrácena nula, jinak -1. Následnì musí být pomocí SDL_GL_GetProcAddress() získány ukazatele na v¹echny OpenGL funkce, vèetnì glEnable(), glBegin() atd., tak¾e pou¾ití této techniky mù¾e leckomu pøipadat velmi tì¾kopádné.</p>


<h2>OpenGL textury a SDL_Surface</h2>

<p>Jednou z velkých výhod spojení OpenGL s knihovnou SDL je mo¾nost nahrávat obrázky pro textury za pou¾ití knihovny SDL_Image. Bohu¾el v¹ak existují dvì pøeká¾ky, které znemo¾òují pøímoèaré pou¾ití.</p>

<p>První z nich je mno¾ství nejrùznìj¹ích vnitøních formátù SDL_Surface, které samotnému SDL sice nevadí, ale pøi pou¾ití kdekoli jinde se na nì musí pamatovat a v¾dy hlídat správný formát. Kdy¾ se pomine paletový re¾im, pak stále zùstává prakticky libovolné umístìní barevných slo¾ek (RGB, BGR apod.). Pravdìpodobnì nejspolehlivìj¹ím pøekonáním tohoto problému je vytvoøit nový surface s pro OpenGL pou¾itelným formátem a pøes SDL_Blit() do nìj zkopírovat pùvodní surface.</p>

<p>Druhý problém spoèívá v tom, ¾e textura vytvoøená ze SDL_Surface je v OpenGL vzhùru nohama, knihovny toti¾ pou¾ívají vzájemnì nekompatibilní souøadnicový systém - v SDL je bod 0, 0 nahoøe, u OpenGL textur standardnì dole.</p>

<p>Øe¹ení je hned nìkolik. V¹ude v programu lze zadávat v koordinát jako 1-v. Tím se sice problém spolehlivì vyøe¹í, ale musí se dávat pozor, aby toto pravidlo nebylo poru¹eno. Textury z více rùzných zdrojù se stanou vra¾ednou kombinací...</p>

<p>Dal¹í mo¾nost spoèívá ve zmìnì souøadnicového systému textur, staèí vlo¾it následující kód do inicializace. Nicménì u textur z více zdrojù mohou opìt vzniknout problémy a psát tyto ètyøi øádky zvlá¹» pøi ka¾dém pou¾ití, nemusí být zrovna pohodlné.</p>

<pre>
glMatrixMode(GL_TEXTURE);
	glLoadIdentity();
	glScalef(1.0f, -1.0f, 1.0f);
glMatrixMode(GL_MODELVIEW);
</pre>

<p>Posledním a asi nejvhodnìj¹ím zpùsobem je pøed vlastním vytvoøením textury pøímo v surface natvrdo prohodit øádky. Tento postup je ukázán ve druhém ukázkovém programu z této lekce.</p>


<h2>Poznámka ohlednì zmìny velikosti okna</h2>

<p>Pøi vytváøení OpenGL aplikací pod knihovnou SDL jsem objevil jistou nekompatibilitu mezi systémy Linux a Windows. Kdy¾ u¾ivatel zmìní velikost okna, aplikace by mìla zareagovat a pøizpùsobit se. Ve Windows staèí aktualizovat OpenGL viewport a perspektivu, nicménì v Linuxu musí být zavolána i funkce SDL_SetVideoMode(). Bez ní bude program vypadat jako na následujícím obrázku - okno se sice roztáhne, ale oblast, do které se kreslí, zùstane nezmìnìna.</p>

<div class="img"><img src="./data/08_resize_lin.png" width="254" height="168" alt="Zmìna velikosti okna v Linuxu" /></div>

<p>Problémem je, ¾e volání SDL_SetVideoMode() zpùsobí ve Windows ztrátu OpenGL kontextu, èili resetují se v¹echna nastavení (barva pozadí, blending, mlha...), zmizí textury, display listy atd.</p>

<div class="img"><img src="./data/08_resize_win.png" width="254" height="168" alt="Zmìna velikosti okna ve Windows" /></div>

<p>Tento problém øe¹ím podmínìným pøekladem. Kdy¾ kompiluji program pro Linux, definuji symbolickou konstantu, která zpùsobí pøidání SDL_SetVideoMode() do kódu, kdy¾ ve Windows, øádek s #define zakomentuji. Mo¾ná to není zrovna nejlep¹í cesta, ale bez problémù funguje. Pokud nìkdo znáte lep¹í øe¹ení, svìøte se prosím do diskuze...</p>

<pre>
#define CALL_SETVIDEOMODE_WHEN_RESIZING

	// O¹etøení události zmìny velikosti okna
	case SDL_VIDEORESIZE:
#ifdef CALL_SETVIDEOMODE_WHEN_RESIZING
		g_screen = SDL_SetVideoMode(event.resize.w,
			event.resize.h, WIN_BPP, WIN_FLAGS);

		if(g_screen == NULL)
		{
			fprintf(stderr,
				"Unable to resize window: %s\n",
				SDL_GetError());
			return false;
		}
#endif
		ResizeGL(event.resize.w, event.resize.h);
		break;
</pre>

<p>Mo¾ná by to ¹lo celé automatizovat pomocí symbolických konstant, které se bìhem pøekladu definují nezávisle na programátorovi a které vìt¹inou obsahují jméno kompilátoru, verzi, operaèní systém atd., ale proè si komplikovat ¾ivot.</p>


<h2>Ukázkové programy</h2>

<h3>RGB Trojúhelník</h3>

<p>Pøíklad ukazuje nastavení OpenGL atributù a vytvoøení okna s podporou OpenGL. Aby nezùstalo jen u èerného pozadí, je vykreslován trojúhelník s lineárním mísením barev. <a href="./src/sdl_08_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/08_prog_a.png" width="328" height="269" alt="RGB trojúhelník" /></div>


<h3>Rotující logo SDL</h3>

<p>Druhý pøíklad vykresluje jednoduchou animaci rotujícího loga knihovny SDL. Obrázek pro texturu je ulo¾en na disku ve formátu PNG a do programu je nahráván pomocí knihovny SDL_image. <a href="./src/sdl_08_b.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/08_prog_b.png" width="328" height="269" alt="Rotující logo SDL" /></div>


<h3>Pohyb v møí¾ce</h3>

<p>Jedná se o jednoduché demo ovládané my¹í, ve kterém se hráè pohybuje møí¾kou. Díky periodickému opakování elementárních bunìk v prostoru nelze nikdy dojít na okraj. Kód je zalo¾en na jedné malé knihovnì, kterou se v poslední dobì sna¾ím dát dohromady, ale zatím je¹tì nebyla nezveøejnìna. (zdrojový kód se zvýraznìním syntaxe: <a href="./src/sdl_08_c_h.html">hlavièkový soubor tøídy aplikace</a>, <a href="./src/sdl_08_c_cpp.html">implementace</a>)</p>

<div class="img"><img src="./data/08_prog_c.png" width="328" height="269" alt="Pohyb v møí¾ce" /></div>


<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_08_a.tar.gz">Pøíklad: RGB Trojúhelník</a></li>
<li><a href="./src/sdl_08_b.tar.gz">Pøíklad: Rotující logo SDL</a></li>
<li><a href="./src/sdl_08_c.tar.gz">Pøíklad: Pohyb v møí¾ce</a></li>
<li><a href="sdl_08.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>V následujícím dílu se podíváme na knihovnu SDL_ttf, která umo¾òuje vypisovat texty.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 21.02.2005</div>

</body>
</html>
