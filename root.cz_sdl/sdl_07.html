<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (7)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (7)</h1>

<p class="perex">Tentokrát se ponoøíme trochu více do hloubky, popí¹eme si SDL grafické struktury a tyto znalosti následnì vyu¾ijeme k pøímému pøístupu k pixelùm obrázku. V závìru budeme také mìnit kurzor my¹i.</p>


<h2>Struktura SDL_Surface</h2>

<p>Ka¾dý u¾ jistì ví, ¾e základem ve¹keré grafiky, kterou poskytuje knihovna SDL, je struktura SDL_Surface. Poprvé jsme se s ní setkali u¾ u funkce SDL_SetVideoMode(), kde pøedstavovala framebuffer okna, a následnì u v¹ech kreslících funkcí. Obecnì mù¾e být jakýmkoli úlo¾i¹tìm pixelù. Pro vlastní programování není znalost jejího vnitøního formátu vìt¹inou nijak zásadní, nicménì alespoò v¹eobecná pøedstava se mù¾e hodit.</p>

<pre>
typedef struct SDL_Surface
{
	Uint32 flags;
	SDL_PixelFormat *format;
	int w, h;
	Uint16 pitch;
	void *pixels;

	SDL_Rect clip_rect;
	int refcount;

	// + dal¹í privátní slo¾ky (viz SDL_video.h)
} SDL_Surface;
</pre>

<p>Polo¾ka flag mù¾e u obecného surface nabývat pouze kombinací hodnot SDL_SWSURFACE, SDL_HWSURFACE a SDL_ASYNCBLIT. Flagy fullscreenu, zmìny velikosti a podobné jsou dostupné pouze u surface okna.</p>

<p>Hardwarový surface a tedy i hardwarovou akceleraci bývá vhodné pou¾ívat pøi blittingu, který se tím výraznì urychlí, naopak pøi èastých modifikacích pixelù (oheò v ukázkovém programu k tomuto èlánku je typickým pøíkladem) není jeho pou¾ití zrovna nejvhodnìj¹í, proto¾e by pixely neustále kolovaly ke grafické kartì a zpìt. V podobných pøípadech je vhodnìj¹í ulo¾it surface do systémové pamìti.</p>

<p>Druhá polo¾ka struktury pøedstavuje formát pixelù (více ní¾e), w a h specifikují rozmìry obrázku v pixelech a pitch je délka jednoho øádku v bytech, ten mù¾e být zarovnán na urèitou velikost. Pointer pixels ukazuje na grafická data obrázku (levý horní roh), jedná se buï o pixely, nebo v pøípadì barevné hloubky osm bitù a men¹í o indexy do palety.</p>

<p>Clip_rect je oøezávací obdélník, díky kterému je mo¾né obrázek pro nìkteré funkce &quot;imaginárnì zmen¹it&quot;, setkali jsme se s ním u¾ minule u funkce SDL_SetClipRect(). Koneènì refcount je poèet referencí, který se pou¾ívá pøi uvolòování obrázku z pamìti. Kromì tìchto parametrù obsahuje SDL_Surface je¹tì dal¹í privátní slo¾ky.</p>

<p>Pozn.: ®ádný z tìchto parametrù, vyjma ruèní modifikace pixelù, by nemìl být zadáván explicitnì. Pro tyto èinnosti slou¾í standardní funkce, které byly probrány v minulých èláncích.</p>


<h2>Struktura SDL_PixelFormat</h2>

<p>Tato struktura popisuje formát pixelù ulo¾ených v surface, její podrobná znalost je nutná jen pøi po¾adavku pøímého pøístupu k pixelùm. V ostatních pøípadech by mìlo staèit pouze vìdìt, ¾e existuje a ¾e ji lze najít v surface->format.</p>

<pre>
typedef struct
{
	SDL_Palette *palette;
	Uint8  BitsPerPixel;
	Uint8  BytesPerPixel;
	Uint32 Rmask, Gmask, Bmask, Amask;
	Uint8  Rloss, Gloss, Bloss, Aloss;
	Uint8  Rshift, Gshift, Bshift, Ashift;
	Uint32 colorkey;
	Uint8  alpha;
} SDL_PixelFormat;
</pre>

<p>Palette buï ukazuje na paletu, nebo je, u barevné hloubky vìt¹í ne¾ 8 bitù, nastaveno na NULL. Barevná hloubka je specifikována hned ve dvou polo¾kách. V první z nich je ulo¾ena v bitech a u druhé jsou jednotkami byty.</p>

<p>Bity RGBA masky jsou na pozici dané slo¾ky v jednièce, RGBA loss urèuje ztrátu pøesnosti barevné slo¾ky - 2<sup>[RGBA]loss</sup>. RGBA shift oznaèuje poèet bitù zprava v hodnotì pixelu k dané komponentì. Colorkey urèuje transparentní barvu a alpha &quot;globální hodnotu alfa kanálu&quot; surface.</p>


<h2>Struktury SDL_Palette a SDL_Color</h2>

<p>Struktura SDL_Palette obsahuje ukazatele na barvy palety a SDL_Color je tvoøena jednotlivými RGB slo¾kami barvy.</p>

<pre>
typedef struct
{
	int ncolors;
	SDL_Color *colors;
} SDL_Palette;

typedef struct
{
	Uint8 r;
	Uint8 g;
	Uint8 b;
	Uint8 unused;
} SDL_Color;
</pre>


<h2>Adresace pixelù a získání barevných komponent</h2>

<p>Pixely jsou v surface ulo¾eny do jednorozmìrného pole, a tudí¾ mù¾e vyvstat otázka, jak je adresovat pøi pou¾ití dvourozmìrných x, y koordinátù. Po¾adovaná adresa pixelu se získá vynásobením ¹íøky øádku y-ovou pozicí a pøiètením x-ové pozice k výsledku. Je nutné vzít v úvahu je¹tì barevnou hloubku, ale jinak se nejedná o nic slo¾itého.</p>

<p>Pøíklad bude mo¾ná názornìj¹í. Na obrázku ní¾e je vidìt møí¾ka, ve které ka¾dý ètvereèek symbolizuje jeden pixel. ©edý okraj vpravo pøedstavuje nevyu¾itou èást pamìti (parametr pitch). Adresa zvýraznìných pixelù (indexù do palety) se bude rovnat (mìøeno v bytech):</p>

<pre>
Uint8 *adr;
int bypp = s->format->BytesPerPixel;

// ADRESA = POÈÁTEK + ØÁDEK*©ÍØKA ØÁDKU
//		+ SLOUPEC*©ÍØKA PIXELU;

// Zelený
adr = (Uint8 *)s->pixels + 2*s->pitch + 3*bypp;
// Èervený
adr = (Uint8 *)s->pixels + 3*s->pitch + 1*bypp;
</pre>

<div class="img"><img src="./data/07_adresace.png" width="122" height="102" alt="Adresace pixelù" /></div>


<p>Je-li pixel naètený, je vìt¹inou potøeba získat hodnoty jednotlivých RGB(A) slo¾ek. ®ádné pevnì dané poøadí (RGB, BGR apod.) není v SDL obecným pravidlem. Jak tedy na to? Pixel se binárnì ANDuje s maskou barvy, èím¾ se vynulují hodnoty v¹ech ostatních komponent, poté se aplikují dva binární posuny, nejprve o shift doprava a následnì o loss doleva.</p>

<p>Po prùchodu následujícím kódem bude promìnná red obsahovat èervenou slo¾ku barvy v pixelu. Získání modré, zelené nebo alfy je analogické.</p>

<pre>
Uint8 red;
Uint32 tmp, pixel;
// fmt je ukazatel na formát pixelù

tmp = pixel &amp; fmt-&gt;Rmask;	// Maskování
tmp = tmp &gt;&gt; fmt-&gt;Rshift;	// Posun na pravý okraj
tmp = tmp &lt;&lt; fmt-&gt;Rloss;	// Expanze na 8 bitù
red = (Uint8)tmp;		// &quot;Oøe¾e&quot; nuly vlevo
</pre>

<p>Druhou mo¾ností by bylo pou¾ít standardní funkci SDL_GetRGB(), která byla popsána v minulém dílu.</p>

<p>Mimochodem, v¾dy je mo¾né si zavést konvenci, ¾e v¹echny surface v programu budou napøíklad ve formátu RGB(A) a tím tyto komplikace obejít. Na druhou stranu, program bude ménì univerzální a pøi skládání dvou kódù vyvíjených nezávisle na sobì mohou vzniknout zbyteèné komplikace.</p>


<h2>Zamknutí surface</h2>

<p>V pøípadì, ¾e chce programátor pøistupovat pøes ukazatel surface->pixels pøímo k jednotlivým pixelùm, mìl by nejdøíve surface uzamknout. Jedinou výjimkou jsou takové surface, u kterých makro SDL_MUSTLOCK() vrátí nulu, pak je pøístup k pixelùm mo¾ný kdykoli.</p>

<p>Za &quot;práci s pixely&quot; se pova¾uje ruèní pøístup k datùm pøes ukazatel ve struktuøe. Naopak u kreslících funkcí, které jsou poskytovány SDL (SDL_BlitSurface() apod.), by surface nikdy být zamknut nemìl!</p>

<pre>
int SDL_LockSurface(SDL_Surface *surface);
void SDL_UnlockSurface(SDL_Surface *surface);
</pre>

<p>Po ukonèení úprav pixelù by mìlo v¾dy následovat odemknutí a jeliko¾ jsou zámky vícenásobné, mìlo by ke ka¾dému zamknutí existovat odpovídající odemknutí. To znamená, ¾e pokud je surface zamknut dvakrát, mìl by být také dvakrát odemknut.</p>

<p>Mezi tìmito funkcemi by se také nemìlo vyskytnout ¾ádné systémové nebo knihovní volání. V obecném pøípadì by zamykání a odemykání mohlo vypadat napø. takto:</p>

<pre>
if(SDL_MUSTLOCK(screen))
{
	if(SDL_LockSurface(screen) &lt; 0)
	{
		return;
	}
}

// Práce s pixely

if(SDL_MUSTLOCK(screen))
{
	SDL_UnlockSurface(screen);
}
</pre>


<h2>Kurzor my¹i</h2>

<p>Na závìr výkladu o SDL grafice bude probráno téma zmìny kurzoru my¹i. K jeho vytvoøení slou¾í funkce SDL_CreateCursor(), která vrací ukazatel na novì vytvoøenou strukturu SDL_Cursor.</p>

<pre>
SDL_Cursor *SDL_CreateCursor(Uint8 *data, Uint8 *mask,
		int w, int h, int hot_x, int hot_y);
</pre>

<p>První dva parametry jsou bitovými mapami a urèují, jak bude výsledný kurzor vypadat (viz dále). Dal¹í dva oznaèují ¹íøku a vý¹ku, obì hodnoty musí být násobkem èísla osm a poslední dva parametry specifikují aktivní bod kurzoru.</p>

<p>Kurzor vytvoøený pomocí SDL mù¾e být pouze èernobílý, tak¾e by mìlo staèit pouze jedno bitové pole. Nesmí se v¹ak zapomenout je¹tì na prùhlednou a pøípadnì invertovanou barvu, co¾ dává celkem ètyøi mo¾né kombinace, jejich¾ význam vysvìtluje následující tabulka.</p>

<table>
<tr align="left">
<th>Data</th>		<th>Maska</th>	<th>Výsledný pixel kurzoru</th>
</tr>

<tr><td>0</td>		<td>1</td>	<td>Bílý</td></tr>
<tr><td>1</td>		<td>1</td>	<td>Èerný</td></tr>
<tr><td>0</td>		<td>0</td>	<td>Prùhledný</td></tr>
<tr><td>1</td>		<td>0</td>	<td>Je-li dostupný, tak invertovaný, jinak èerný</td></tr>
</table>

<p>Po skonèení práce s kurzorem by mìla být v¾dy zavolána funkce SDL_FreeCursor(), která se postará o jeho uvolnìní z pamìti.</p>

<pre>
void SDL_FreeCursor(SDL_Cursor *cursor);
</pre>


<p>Kurzor lze nastavit za aktivní voláním funkce SDL_SetCursor(). Naopak aktuálnì aktivní kurzor lze získat funkcí SDL_GetCursor().</p>

<pre>
void SDL_SetCursor(SDL_Cursor *cursor);
SDL_Cursor *SDL_GetCursor(void);
</pre>

<p>Poslední operací, která se dá provést s kurzorem my¹i, je jeho zobrazení popø. skrytí. Po startu aplikace je implicitnì zobrazen.</p>

<pre>
int SDL_ShowCursor(int toggle);
</pre>

<p>Symbolická konstanta SDL_DISABLE kurzor skryje, naopak SDL_ENABLE ho zobrazí. Pomocí SDL_QUERY bude vrácen aktuální stav.</p>


<p>V následujícím pøíkladu se vytvoøí kurzor ve tvaru bílého ètverce o velikosti 8x8 pixelù, za aktivní bod je definován levý horní roh.</p>

<pre>
// Globální promìnná
SDL_Cursor *g_cursor;

// Inicializace
Uint8 data[] = { 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00 };
Uint8 mask[] = { 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF };

g_cursor = SDL_CreateCursor(data, mask, 8, 8, 0, 0);
SDL_SetCursor(g_cursor);

// Deinicializace (vìt¹inou konec aplikace)
SDL_FreeCursor(g_cursor);
</pre>

<p>Pozn.: SDL sice umo¾òuje vytváøet pouze èernobílé kurzory, ale to neznamená, ¾e nelze pou¾ívat i barevné. V¾dy je mo¾né pomocí SDL_ShowCursor(SDL_DISABLE) standardní kurzor skrýt a místo nìho pøi ka¾dém vykreslení zobrazit libovolný obrázek nebo dokonce spritovou animaci (animovaný kurzor).</p>


<h2>Ukázkové programy</h2>

<h3>Pøímý pøístup k pixelùm surface</h3>

<p>Pøi ruèní modifikaci pixelù bývá nejvìt¹ím problémem adresovat místo v pamìti, na které se má zapisovat. O tuto èinnost se stará funkce DrawPixel(), která byla pøevzata ze SDL intro a trochu upravena. Demonstraèní program touto technikou vykreslí tøi ètverce a linku palety ¹edi. <a href="./src/sdl_07_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/07_prog_a.png" width="328" height="269" alt="Pøímý pøístup k pixelùm surface" /></div>


<h3>Oheò</h3>

<p>Druhý pøíklad simuluje hoøící oheò. Na nejni¾¹ím øádku se generují náhodné pixely z palety barev ohnì, které se s rostoucí vý¹kou postupnì rozmazávají. V programu je dále definován kurzor my¹i ve tvaru &quot;zamìøovaèe&quot; (èerné koleèko s bílým støedem; na screenshotu není vidìt), kterým je mo¾né do ohnì pøidávat bílé pixely. <a href="./src/sdl_07_b.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/07_prog_b.png" width="328" height="148" alt="Oheò" /></div>


<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_07_a.tar.gz">Pøíklad: Pøímý pøístup k pixelùm surface</a></li>
<li><a href="./src/sdl_07_b.tar.gz">Pøíklad: Oheò</a></li>
<li><a href="sdl_07.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Tímto èlánkem jsme SDL grafiku ukonèili, pøí¹tì se budeme vìnovat OpenGL.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 07.03.2005</div>

</body>
</html>
