<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (14)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (14)</h1>

<p class="perex">Joysticky, kniply, páky a jiné ovladaèe bývají nedílnou souèástí vìt¹iny her, hlavnì simulátorù. Tento díl bude vìnován právì jim.</p>


<p>Upozornìní: Hned na zaèátku je potøeba øíct, ¾e jsem nikdy s ¾ádným joystickem nepracoval a nemám ho ani k dispozici! Proto¾e je v¹ak nedílnou souèástí SDL, mìlo by mu nìjaké místo být vìnováno. V¹e, co zde tedy bude napsáno, vychází výhradnì ze SDL dokumentace a bohu¾el není z mé strany ¾ádným zpùsobem ovìøeno.</p>


<h2>Pøíprava Joysticku pro pou¾ití</h2>

<p>Základním pøedpokladem, aby mohl být joystick v aplikaci pou¾íván, je pøedání symbolické konstanty SDL_INIT_JOYSTICK do parametrù funkce SDL_Init(), která inicializuje SDL.</p>

<p>Dal¹ím dùle¾itým krokem pøípravy je dotaz, kolik joystickù je pøipojeno k poèítaèi. SDL k tomu poskytuje funkci SDL_NumJoysticks(), její návratovou hodnotou je samozøejmì daný poèet.</p>

<pre>
int SDL_NumJoysticks(void);
</pre>

<p>Víme-li, ¾e je k poèítaèi alespoò jeden joystick pøipojen, lze pøistoupit k jeho otevøení, které se vykoná voláním funkce SDL_JoystickOpen().</p>

<pre>
SDL_Joystick *SDL_JoystickOpen(int device_index);
</pre>

<p>Za parametr se pøedává index joysticku, co¾ je v podstatì jeho poøadí v systému. Hodnoty mohou být pouze v rozmezí 0 a¾ SDL_NumJoysticks()-1. Pomocí tohoto èísla bedeme také joystick identifikovat pøi zpracování událostí, ale o tom a¾ pozdìji.</p>

<p>Návratovou hodnotou funkce je ukazatel na objekt struktury SDL_Joystick, který budeme pøedávat do v¹ech joystickových funkcí, v pøípadì neúspìchu pak NULL.</p>

<p>Kdekoli v aplikaci mù¾e být vznesen dotaz, zda je joystick otevøen nebo ne. Slou¾í k tomu funkce SDL_JoystickOpened(), která, je-li otevøen, vrátí jednièku, jinak nulu.</p>

<pre>
int SDL_JoystickOpened(int device_index);
</pre>

<p>Po skonèení práce by mìly být uvolnìny v¹echny zdroje, které aplikace alokovala, to samé platí i pro joysticky.</p>

<pre>
void SDL_JoystickClose(SDL_Joystick *joystick);
</pre>

<p>Následující pøíklad demonstruje obecnou inicializaci joysticku.</p>

<pre>
// Globální promìnná
SDL_Joystick *g_joy = NULL;

// Inicializace
SDL_Init(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK);

// Je vùbec nìjaký joystick dostupný?
if(SDL_NumJoysticks() > 0)
{
	// Pokud ano, jeden otevøe
	g_joy = SDL_JoystickOpen(0);

	if(g_joy == NULL)
		fprintf(stderr, "Nepodaøilo se otevøít joystick.\n");
}

// Deinicializace
if(g_joy != NULL)
	SDL_JoystickClose(g_joy);
</pre>


<h2>Informace o otevøeném joysticku</h2>

<p>K získání jména joysticku slou¾í funkce SDL_JoystickName(), která vrací øetìzec ukonèený NULL. Jeliko¾ se za parametr pøedává pouze index zaøízení, lze tuto funkci volat je¹tì pøed vlastním otevøením joysticku. Není-li ¾ádné jméno dostupné, je vráceno NULL.</p>

<pre>
const char *SDL_JoystickName(int device_index);
</pre>

<p>Index zaøízení se z joystickové struktury získá funkcí SDL_JoystickIndex().</p>

<pre>
int SDL_JoystickIndex(SDL_Joystick *joystick);
</pre>

<p>Pomocí následujících ètyø funkcí se provádí dotazy na technické parametry daného joysticku. Funkce vrací po øadì poèet os (páka), trackballù, klobouèkù (POV Hat) a tlaèítek.</p>

<pre>
int SDL_JoystickNumAxes(SDL_Joystick *joystick);
int SDL_JoystickNumBalls(SDL_Joystick *joystick);
int SDL_JoystickNumHats(SDL_Joystick *joystick);
int SDL_JoystickNumButtons(SDL_Joystick *joystick);
</pre>

<p>V následujícím pøíkladu otevøeme první joystick a vypí¹eme o nìm do konzole v¹echny informace, které se dají zjistit.</p>

<pre>
SDL_Joystick *joy;

if(SDL_NumJoysticks() > 0)
{
	// Otevøe první joystick
	joy = SDL_JoystickOpen(0);

	if(joy)
	{
		printf("Joystick #0\n");
		printf("Jméno: %s\n",
			SDL_JoystickName(0));
		printf("Poèet os: %d\n",
			SDL_JoystickNumAxes(joy));
		printf("Poèet klobouèkù: %d\n",
			SDL_JoystickNumHats(joy));
		printf("Poèet trackballù: %d\n",
			SDL_JoystickNumBalls(joy));
		printf("Poèet tlaèítek: %d\n",
			SDL_JoystickNumButtons(joy));
	}
	else
		printf("Nelze otevøít joystick #0\n");

	// Zavøe joystick
	if(SDL_JoystickOpened(0))
		SDL_JoystickClose(joy);
}
</pre>

<p>Pokud by bylo potøeba získat informace o v¹ech joysticích v systému, není problém vlo¾it tento kód do cyklu.</p>


<h2>Události joysticku</h2>

<p>Události joysticku jsou implicitnì vypnuty, a proto, aby se jejich doruèování povolilo, je nutné zavolat funkci SDL_JoystickEventState(). Za její parametr mù¾e být pøedána jedna ze symbolických konstant SDL_QUERY, SDL_ENABLE popø. SDL_IGNORE.</p>

<pre>
int SDL_JoystickEventState(int state);
</pre>

<p>Ka¾dá z jednotlivých èástí joysticku má pøiøazenu vlastní událost. Jedna pro pohyb pákou, jedna pro tlaèítka, dal¹í pro trackball a je¹tì jedna pro klobouèek - celkem ètyøi události. Asi nejlep¹í bude, kdy¾ pùjdeme popoøadì.</p>


<h3>Osa (páka) - SDL_JoyAxisEvent</h3>

<p>Pokud je parametr event.type události nastaven na hodnotu SDL_JOYAXISMOTION, jedná se o pohyb pákou. Dal¹í informace se pak hledají v parametru event.jaxis, co¾ je objekt struktury SDL_JoyAxisEvent.</p>

<pre>
typedef struct
{
	Uint8 type;
	Uint8 which;
	Uint8 axis;
	Sint16 value;
} SDL_JoyAxisEvent;
</pre>

<p>Jak brzy uvidíme, je parametr which pøítomen u v¹ech joystickových zpráv, jedná se o index joysticku, na kterém událost nastala. Axis pøedstavuje index osy, na vìt¹inì moderních zaøízení je osa x reprezentována nulou a y jednièkou. Value udává aktuální polohu páky, je to èíslo v rozmezí od -32768 do 32767.</p>


<h3>Tlaèítka - SDL_JoyButtonEvent</h3>

<p>Dal¹í joystickovou událostí, kterou SDL poskytuje, je stisk respektive uvolnìní nìkterého z tlaèítek. Parametr type v takovém pøípadì obsahuje buï hodnotu SDL_JOYBUTTONDOWN, nebo SDL_JOYBUTTONUP a objekt v SDL_Event má jméno event.jbutton.</p>

<pre>
typedef struct
{
	Uint8 type;
	Uint8 which;
	Uint8 button;
	Uint8 state;
} SDL_JoyButtonEvent;
</pre>

<p>Promìnná button opìt obsahuje index tlaèítka a state mù¾e být nastaveno na SDL_PRESSED nebo SDL_RELEASED. Tato informace u¾ v¹ak byla získána z parametru type.</p>


<h3>Trackball - SDL_JoyBallEvent</h3>

<p>Dal¹í èást joysticku, která mù¾e generovat události, je trackball. Jméno zprávy je nastaveno na SDL_JOYBALLMOTION a informace se hledají v event.jball, promìnné struktury SDL_JoyBallEvent.</p>

<pre>
typedef struct
{
	Uint8 type;
	Uint8 which;
	Uint8 ball;
	Sint16 xrel, yrel;
} SDL_JoyBallEvent;
</pre>

<p>Parametr ball oznaèuje index trackballu a xrel spolu s yrel udává relativní pohyb na osách x a y. Absolutní pozici nelze, kvùli obecné podstatì trackballu, získat.</p>


<h3>Klobouèek - SDL_JoyHatEvent</h3>

<p>Událost klobouèku má jméno SDL_JOYHATMOTION a informace jsou ulo¾eny v event.jhat.</p>

<pre>
typedef struct
{
	Uint8 type;
	Uint8 which;
	Uint8 hat;
	Uint8 value;
} SDL_JoyHatEvent;
</pre>

<p>V parametru hat je analogicky index klobouèku a value obsahuje pozici. Jedná se o binárnì ORovanou kombinaci následujících symbolických konstant. Jejich význam je jistì ka¾dému jasný.</p>

<pre>
SDL_HAT_CENTERED
SDL_HAT_UP
SDL_HAT_RIGHT
SDL_HAT_DOWN
SDL_HAT_LEFT
</pre>

<p>Dále mohou být pou¾ity také pøeddefinové kombinace.</p>

<pre>
#define SDL_HAT_RIGHTUP		(SDL_HAT_RIGHT|SDL_HAT_UP)
#define SDL_HAT_RIGHTDOWN	(SDL_HAT_RIGHT|SDL_HAT_DOWN)
#define SDL_HAT_LEFTUP		(SDL_HAT_LEFT|SDL_HAT_UP)
#define SDL_HAT_LEFTDOWN	(SDL_HAT_LEFT|SDL_HAT_DOWN)
</pre>


<h2>&quot;Pøímý&quot; pøístup</h2>

<p>Dal¹í mo¾ností, jak pøistupovat k joysticku, jsou, stejnì jako u my¹i nebo klávesnice, pøímé dotazy na jeho stav. Mimochodem, na mnoha místech SDL dokumentace se objevují poznámky, ¾e je lep¹í preferovat události.</p>

<p>Pokud nejsou zapnuté joystickové události, je nutné pro získání informací volat funkci SDL_JoystickUpdate(), která aktualizuje stav v¹ech èástí v¹ech pøipojených joystickù. Pøi událostním systému je volána automaticky.</p>

<pre>
void SDL_JoystickUpdate(void);
</pre>


<h3>Osa (páka)</h3>

<p>Pro zji¹tìní polohy páky slou¾í funkce SDL_JoystickGetAxis(). Za první parametr se pøedává ukazatel na strukturu joysticku - toto je obecné pravidlo v¹ech funkcí pro pøímý pøístup.</p>

<pre>
Sint16 SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis);
</pre>

<p>Druhý parametr specifikuje index osy a návratovou hodnotou je její pozice. Nìkdy mù¾e být nutné poèítat s jistou tolerancí, která padá na úèet chvìní. Je zajímavé, ¾e nìkteré joysticky pou¾ívají osy 2 a 3 coby extra tlaèítka.</p>

<p>Následující pøíklad je opìt pøebrán ze SDL dokumentace, je v nìm ukázáno, jak podle polohy páky urèit smìr pohybu.</p>

<pre>
Sint16 x_move, y_move;
SDL_Joystick *joy1;

// Inicializace joy1...

x_move = SDL_JoystickGetAxis(joy1, 0);
y_move = SDL_JoystickGetAxis(joy1, 1);
</pre>


<h3>Tlaèítka</h3>

<p>Druhým parametrem funkce SDL_JoystickGetButton() je mo¾né specifikovat tlaèítko, jeho¾ stav potøebujeme zjistit. Je-li stisknuto, vrátí funkce jednièku a pokud ne, nulu.</p>

<pre>
Uint8 SDL_JoystickGetButton(SDL_Joystick *joystick, int button);
</pre>


<h3>Trackball</h3>

<p>Následující funkcí lze zjistit relativní pohyb trackbalu, hodnoty se v¾dy vztahují k minulému volání. V pøípadì úspìchu je vrácena nula, jinak -1.</p>

<pre>
int SDL_JoystickGetBall(SDL_Joystick *joystick,
		int ball, int *dx, int *dy);
</pre>

<p>V pøíkladu ní¾e se program pokusí zjistit pøírùstky relativní pozice trackballu a následnì je vypsat na terminál.</p>

<pre>
int delta_x, delta_y;
SDL_Joystick *joy;

SDL_JoystickUpdate();

if(SDL_JoystickGetBall(joy, 0, &amp;delta_x, &amp;delta_y) == -1)
	printf("Chyba pøi ètení trackballu!\n");
else
	printf("Trackball delta - X:%d, Y:%d\n",
			delta_x, delta_y);
</pre>


<h3>Klobouèek</h3>

<p>Ke klobouèku se pøistupuje funkcí SDL_JoystickGetHat(). Její návratovou hodnotou je kombinace symbolických konstant, které u¾ byly popsány u událostí.</p>

<pre>
Uint8 SDL_JoystickGetHat(SDL_Joystick *joystick, int hat);
</pre>


<h2>Force Feedback</h2>

<p>Force Feedback bohu¾el není v souèasné dobì podporován. SDL dokumentace uvádí, ¾e Sam Lantinga &lt;slouken@libsdl.org&gt; (autor SDL) sna¾nì prosí osoby, které mají s tìmito technikami nìjaké zku¹enosti, o nápady, jak co nejlépe navrhnout API.</p>


<h2>Ukázkové programy</h2>

<p>Jak jsem psal na zaèátku, s joysticky nemám naprosto ¾ádné zku¹enosti. Navíc ¾ádný nevlastním, a proto, i kdybych nìco stvoøil, nedokázal bych ovìøit funkènost a pøípadnì program odladit. Z tohoto dùvodu nebude tento díl obsahovat ¾ádný ukázkový program :-(</p>

<p>Nicménì jeden mùj kamarád, Ladislav Zima, je lídrem nezávisleho herního vývojového týmu <a href="http://zimtech.ceskehry.cz/">Zimtech</a>. Ve høe <a href="http://zimtech.ceskehry.cz/hotove.html">Becher Rescue</a> ovládání pomocí joystickù implementoval, tak¾e pokud máte chu», není nic snaz¹ího, ne¾ nahlédnout do zdrojových kódù (GNU GPL). Jedná se o soubor main.cpp, od øádku 73.</p>

<p>Tímto bych mu chtìl také veøejnì podìkovat za pøeètení èlánku a upozornìní na nejvìt¹í chyby, jich¾ jsem se dopustil.</p>

<p>Události joysticku/gamepadu se v Becher Rescue mapují na zpracování událostí klávesnice. Pokud je pozice páky mimo &quot;mrtvou zónu&quot; (dead-zone - joysticky jako analogová zaøízení se nedr¾í pøesnì v nule, ale pozice páky se lehce &quot;klepe&quot; okolo ní), jakoby zmáèkne pøíslu¹né tlaèítko na klávesnici pro pohyb postavy. Ignoruje se tedy vzdálenost páky od støedu.</p>

<p>Je¹tì jedna poznámka: na mnoha joysticích a gamepadech se neposílá událost uvolnìní tlaèítka, tak¾e s tím poèítejte. V Becher Rescue se zmáèknutí tlaèítka joysticku pøevede na zvednutí a opìtovné stisknutí pøíslu¹né klávesy panáèka.</p>


<h2>Download</h2>

<p><ul>
<li><a href="sdl_14.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>V pøí¹tím díle budou probrány v¹echny ostatní SDL události a tím bude tento tematický celek ukonèen.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 01.05.2005</div>

</body>
</html>
