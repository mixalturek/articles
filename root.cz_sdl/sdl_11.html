<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (11)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (11)</h1>

<p class="perex">Na konci minulého dílu jsme nakousli základní práci s událostmi, dnes budeme pokraèovat. Tento èlánek je primárnì vìnován práci s frontou událostí, ale jeliko¾ je¹tì nevíme nic o unionu SDL_Event, bude èásteènì probrán i on.</p>


<p>Základem zpracování událostí je v SDL union SDL_Event a funkce, které naèítají tyto objekty z fronty zpráv. Nejdøíve bude v rychlosti probrána zmínìná datová struktura a pak se budeme celý zbytek èlánku vìnovat práci s frontou událostí.</p>


<h2>Union SDL_Event</h2>

<p>Pro ty kteøí u¾ zapomnìli... Datový typ union je podobný klasické struktuøe, rozdíl mezi nimi spoèívá v tom, ¾e v urèitém okam¾iku mù¾e v jeho vnitøku existovat v¾dy jen jedna z deklarovaných polo¾ek. Pøi vytváøení se alokuje pamì» o velikosti nejvìt¹í z nich.</p>

<p>Union SDL_Event je pravdìpodobnì, hned po SDL_Surface, druhý nejdùle¾itìj¹í a nejpou¾ívanìj¹í ze v¹ech SDL datových typù. Jak u¾ bylo nìkolikrát zmínìno, poskytuje programátorovi rozhraní pro práci s událostmi.</p>

<pre>
typedef union
{
	Uint8 type;			// Typ události

	SDL_ActiveEvent		active;	// (De)aktivace okna
	SDL_KeyboardEvent	key;	// Klávesnice
	SDL_MouseMotionEvent	motion;	// My¹
	SDL_MouseButtonEvent	button;
	SDL_JoyAxisEvent	jaxis;	// Joystick
	SDL_JoyBallEvent	jball;
	SDL_JoyHatEvent		jhat;
	SDL_JoyButtonEvent	jbutton;
	SDL_ResizeEvent		resize;	// Zmìna velikosti okna
	SDL_ExposeEvent		expose;	// Po¾adavek na pøekreslení
	SDL_QuitEvent		quit;	// Po¾adavek na ukonèení
	SDL_UserEvent		user;	// U¾ivatelská událost
	SDL_SywWMEvent		syswm;	// Systémovì závislá
} SDL_Event;
</pre>

<p>Jak to v¹echno funguje? Kdy¾ u¾ivatel napøíklad zmìní velikost okna, SDL vygeneruje objekt SDL_Event, atribut type nastaví na hodnotu SDL_VIDEORESIZE a do jeho parametrù (podobjekt resize) ulo¾í nové rozmìry okna. Celý objekt je pak vlo¾en do fronty událostí.</p>

<p>Detekuje-li aplikace pøíchod zprávy, podle parametru type zjistí, ¾e se jedná o zmìnu velikosti okna a v resize.w, resize.h najde nové rozmìry. V závislosti na nich pak provede odpovídající akci - napøíklad pøekreslí scénu nebo aktualizuje OpenGL perspektivu.</p>

<p>Promìnná type mù¾e nabývat hodnot uvedených v následující tabulce v levém sloupci. Vpravo se pak nachází odpovídající struktura, ve které se hledají podrobnosti o události.</p>

<table>
<tr align="left"><th>Typ události</th>	<th>Odpovídající struktura</th></tr>
<tr><td>SDL_ACTIVEEVENT</td>		<td>SDL_ActiveEvent</td></tr>
<tr><td>SDL_KEYDOWN/UP</td>		<td>SDL_KeyboardEvent</td></tr>
<tr><td>SDL_MOUSEMOTION</td>		<td>SDL_MouseMotionEvent</td></tr>
<tr><td>SDL_MOUSEBUTTONDOWN/UP</td>	<td>SDL_MouseButtonEvent</td></tr>
<tr><td>SDL_JOYAXISMOTION</td>		<td>SDL_JoyAxisEvent</td></tr>
<tr><td>SDL_JOYBALLMOTION</td>		<td>SDL_JoyBallEvent</td></tr>
<tr><td>SDL_JOYHATMOTION</td>		<td>SDL_JoyHatEvent</td></tr>
<tr><td>SDL_JOYBUTTONDOWN/UP</td>	<td>SDL_JoyButtonEvent</td></tr>
<tr><td>SDL_QUIT</td>			<td>SDL_QuitEvent</td></tr>
<tr><td>SDL_VIDEORESIZE</td>		<td>SDL_ResizeEvent</td></tr>
<tr><td>SDL_VIDEOEXPOSE</td>		<td>SDL_ExposeEvent</td></tr>
<tr><td>SDL_USEREVENT</td>		<td>SDL_UserEvent</td></tr>
<tr><td>SDL_SYSWMEVENT</td>		<td>SDL_SysWMEvent</td></tr>
</table>

<p>Proto¾e popis tìchto struktur a v¹eho, co s nimi souvisí, zabere nìkolik následujících èlánkù, budeme se nejprve vìnovat funkcím, které vyzvedávají události z fronty a pak a¾ konkrétnímu popisu jednotlivých zpráv.</p>


<h2>Naèítání událostí z fronty</h2>

<p>Existují dva základní zpùsoby, jak naèíst událost z fronty, v SDL je reprezentují funkce SDL_PollEvent() a SDL_WaitEvent(). Obì vezmou událost, která je zrovna na øadì, zkopírují její data do pøedaného parametru a odstraní ji z fronty. Co se stane s událostí dál, zále¾í na programátorovi, který vytváøí aplikaci.</p>

<pre>
int SDL_PollEvent(SDL_Event *event);
int SDL_WaitEvent(SDL_Event *event);
</pre>

<p>Rozdíl mezi tìmito funkcemi se projeví a¾ tehdy, kdy¾ je fronta prázdná. Jak u¾ z názvu SDL_WaitEvent() vyplývá, tato funkce èeká libovolnì dlouho, dokud nìjaká zpráva nedorazí. Narozdíl od toho, SDL_PollEvent() se v pøípadì prázdné fronty ihned ukonèí a nulovým návratovým kódem oznámí, ¾e nebylo naèteno nic. V ostatních pøípadech vrátí jednièku, která vyjadøuje, ¾e byla nìjaká zpráva naètena a má se zpracovat. SDL_WaitEvent() naproti tomu vrátí nulu, pouze pokud nastane nìjaká chyba.</p>

<p>Události se typicky zpracovávají v cyklu, který se ukonèí, kdy¾ je fronta prázdná.</p>

<pre>
SDL_Event event;
while(SDL_PollEvent(&amp;event))
{
	// Zpracování události
}

// V¹echny události zpracovány
</pre>

<p>Mù¾e vyvstat otázka, kterou z funkcí je lep¹í pou¾ívat. Dá se øíci, ¾e v 99 procentech pøípadù sáhne programátor po SDL_PollEvent() a SDL_WaitEvent() pou¾ije pouze ve výjimeèných pøípadech. Dùvodem je, ¾e program potøebuje neustále provádìt urèitou èinnost, jako jsou animace a herní logika. Systémové èasovaèe v¹ak nemusí být pro tento typ úloh zrovna nejlep¹í volbou, proto¾e jsou vìt¹inou výraznì pomalej¹í ne¾ cyklus, který se provádí neustále dokola. U jednoduchých her je v podstatì jedno, co se pou¾ije, nicménì u trochu slo¾itìj¹ích bývají s rychlostí velké problémy.</p>

<p>Události se naèítají ze vstupních zaøízení funkcí SDL_PumpEvents(), bez ní by nikdy aplikaci nepøi¹la ¾ádná zpráva. V SDL_PollEvent() a SDL_WaitEvent() je volána automaticky, pøi jiném zpùsobu naèítání zpráv musí být pou¾ita explicitnì.</p>

<pre>
void SDL_PumpEvents(void);
</pre>

<p>SDL dokumentace uvádí, ¾e SDL_PumpEvents() nesmí být pou¾ito v jiném vláknu ne¾, ve kterém bylo voláno SDL_SetVideoMode().</p>


<h2>Vkládání událostí do fronty</h2>

<p>Událostní systém v SDL není pouze jednosmìrný, ale mù¾e být pou¾it i k dialogu mezi rùznými èástmi aplikace. Funkce SDL_PushEvent() pøebírá ukazatel na objekt události, který umístí do fronty (resp. její kopii), a v pøípadì úspìchu vrátí 0, jinak -1.</p>

<pre>
int SDL_PushEvent(SDL_Event *event);
</pre>

<p>Vìt¹inou se posílají u¾ivatelské události (SDL_USEREVENT), ale jeliko¾ je¹tì nebyly vysvìtleny, uká¾eme si poslání na SDL_QUIT. Tato událost zprostøedkovává programu po¾adavek na ukonèení a nepøebírá ¾ádné parametry.</p>

<pre>
void PushQuitEvent()
{
	SDL_Event event;
	event.type = SDL_QUIT;
	SDL_PushEvent(&amp;event);
}
</pre>

<p>Kdykoli by byla v programu zavolána tato funkce, aplikace by byla ukonèena (pøedpokládá se standardní ukonèení aplikace po pøíchodu SDL_QUIT).</p>


<h2>Obecná práce s frontou</h2>

<p>V¹echny èinnosti s frontou zpráv, které byly právì probrány, a také nìkteré dal¹í, mohou být provedeny pomocí SDL_PeepEvents(). Tato obecná funkce pøebírá v prvních dvou parametrech ukazatel na pole událostí a samozøejmì jeho velikost.</p>

<pre>
int SDL_PeepEvents(SDL_Event *events, int numevents,
		SDL_eventaction action, Uint32 mask);
</pre>

<p>Parametr action specifikuje, co se má vykonat. Je-li nastaven na SDL_ADDEVENT, jsou události z pole vlo¾eny do fronty, v pøípadì SDL_PEEKEVENT budou vráceny, ale ne vymazány. K vrácení a následnému vymazání z fronty slou¾í SDL_GETEVENT.</p>

<p>Poslední parametr definuje masku událostí, se kterými se má pracovat. Jedná se o ANDované flagy makra SDL_EVENTMASK(typ_události). Také se mohou pou¾ít pøímé názvy masek, lze je najít v hlavièkovém souboru SDL_events.h. Maska pro libovolné události nese oznaèení SDL_ALLEVENTS.</p>

<p>Návratová hodnota pøedstavuje poèet vlo¾ených/naètených událostí, v pøípadì chyby je vráceno -1.</p>


<h2>Zákaz generování nìkterých událostí</h2>

<p>Pomocí funkce SDL_EventState() lze specifikovat, jestli se mají události daného typu vkládat do fronty, nebo ne. První parametr specifikuje typ události a druhý urèuje èinnost funkce. Je-li pøedán flag SDL_IGNORE, události se do fronty vkládat nebudou, v pøípadì SDL_ENABLE se zpracovávají normálnì a SDL_QUERY slou¾í k dotazùm. Vrácen je v¾dy stav po modifikaci.</p>

<pre>
Uint8 SDL_EventState(Uint8 type, int state);
</pre>

<p>Tato funkce se uplatní pøedev¹ím pøi pou¾ívání technik, které zji¹»ují stav vstupních zaøízení pøímo a bylo by tedy zbyteèné generovat události. Napøíklad funkce SDL_GetKeyState() umo¾òuje programátorovi dotázat se na stisk klávesy. K tomu v¹ak a¾ pøí¹tì.</p>

<p>Pomocí následujících dvou øádkù lze zakázat generování v¹ech událostí klávesnice.</p>

<pre>
SDL_EventState(SDL_KEYUP, SDL_IGNORE);
SDL_EventState(SDL_KEYDOWN, SDL_IGNORE);
</pre>


<h2>Filtr událostí</h2>

<p>O nìco flexibilnìj¹í ne¾ pøedchozí funkce je SDL_SetEventFilter(), pomocí které lze do SDL pøedat ukazatel na rutinu, jen¾ mù¾e filtrovat události nejen podle typu, ale i podle ostatních parametrù.</p>

<pre>
void SDL_SetEventFilter(SDL_EventFilter filter);
SDL_EventFilter SDL_GetEventFilter(void);
</pre>

<p>Typ SDL_EventFilter je definován jako ukazatel na funkci, které je v parametru pøedán ukazatel na událost. Vrátí-li tato funkce èíslo jedna, bude událost vlo¾ena do fronty, v pøípadì nuly nebude.</p>

<pre>
typedef int (*SDL_EventFilter)(const SDL_Event *event);
</pre>

<p>Jediná pøipomínka vzniká u události SDL_QUIT. Filtr je pro ni volán pouze tehdy, pokud správce oken vy¾aduje zavøít okno aplikace. V takovém pøípadì vrácená jednièka øíká, aby bylo okno zavøeno, cokoli jiného ponechá okno otevøené (je-li to mo¾né). Pokud je vyvoláno SDL_QUIT kvùli signálu o pøeru¹ení, filtr volán nebude a zpráva je v¾dy doruèena pøímo aplikaci.</p>

<p>A je¹tì dvì krátké poznámky: Filtr není volán na události, které vkládá do fronty sama aplikace (SDL_PushEvent(), SDL_PeepEvents()), a jeliko¾ mù¾e být vykonáván v jiném vláknu, mìli byste si dávat pozor, co v nìm dìláte.</p>

<p>V následujícím pøíkladu má SDL zakázáno generovat události klávesnice, pokud se nejedná o klávesu abecedního znaku nebo èísla. Je to vlastnì analogie pøíkladu u funkce SDL_EventState(), nicménì zde byl výbìr navíc omezen podle parametrù. V¹imnìte si, ¾e filtr má podobnou strukturu jako samotné zpracovávání událostí.</p>

<pre>
#include &lt;ctype.h&gt;// Kvùli isalnum()

int EventFilter(const SDL_Event *event)
{
	switch(event->type)
	{
	case SDL_KEYDOWN:
		// Abecední znak nebo èíslo?
		if(isalnum(event->key.keysym.sym))
			return 1;// Vlo¾it
		else
			return 0;// Nevkládat
		break;

	default:
		break;
	}

	return 1;// Vlo¾it
}

// Zapnutí filtru napø. v Init()
SDL_SetEventFilter(EventFilter);
</pre>


<h2>Ukázkové programy</h2>

<h3>Fronta událostí</h3>

<p>Program demonstruje nejèastìj¹í techniky pou¾ívané pøi práci s frontou událostí. Jsou jimi naèítání a vkládání zpráv z/do fronty a filtrování událostí. Pomocí mezerníku lze zapínat a vypínat filtrování zpráv o uvolnìní kláves (pøi pøíchodu se vypí¹e oznámení do konzole), zprávy týkající se my¹i se v¾dy ignorují. Stejnì jako u pøíkladu z minula, ani zde se nic nevykresluje. <a href="./src/sdl_11_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/11_prog_a.png" width="328" height="269" alt="Fronta událostí" /></div>


<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_11_a.tar.gz">Pøíklad: Fronta událostí</a></li>
<li><a href="sdl_11.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Dne¹ním dílem jsme postavili spí¹e teoretické základy pro zpracování událostí. Pøí¹tì budeme u¾ konkrétnìj¹í, je vìnován zpracování vstupù z klávesnice.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 10.04.2005</div>

</body>
</html>
