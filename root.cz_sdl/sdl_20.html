<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (20)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (20)</h1>

<p class="perex">Ve 20. díle dokonèíme popis knihovny SDL_mixer. Budeme se bavit pøedev¹ím o hudbì a speciálních efektech, jako je nastavení rozdílné hlasitosti levého a pravého kanálu nebo simulace zti¹ení vlivem vzdálenosti zdroje zvuku od posluchaèe.</p>


<h2>Hudba</h2>

<p>Pøehrávání hudby je v SDL_mixeru kompletnì oddìlené od normálních zvukových kanálù a tudí¾ musí mít své vlastní rozhraní. Hudba je reprezentován strukturou Mix_Music a stejnì jako u zvukù i zde staèí znát pouze jméno, ve¹keré operace se provádìjí pomocí API funkcí.</p>

<p>Pozn.: Rozhraní zvukù a hudby si je velice podobné, a proto zkusím popis trochu urychlit. Také nemám rád copy &amp; paste èlánky...</p>

<p>Hudba se nahrává funkcí Mix_LoadMUS() a po skonèení práce se uvolòuje pomocí Mix_FreeMusic().</p>

<pre>
Mix_Music *Mix_LoadMUS(const char *file);
void Mix_FreeMusic(Mix_Music *music);
</pre>

<p>Samotné pøehrávání zaèíná a¾ po zavolání jedné z následujících tøí funkcí. U poslední z nich se nezaèíná hned od zaèátku, ale od libovolného místa skladby, jeho definice je ale bohu¾el závislá na typu zvukového souboru - viz Mix_SetMusicPosition() ní¾e.</p>

<pre>
int Mix_PlayMusic(Mix_Music *music, int loops);
int Mix_FadeInMusic(Mix_Music *music, int loops, int ms);

int Mix_FadeInMusicPos(Mix_Music *music, int loops,
		int ms, double position);
</pre>

<p>Dal¹í zpùsob, jak pøehrávat hudbu, je technika ne nepodobná SDL. Je nutné napsat mixovací funkci a poté na ni pøedat pomocí Mix_HookMusic() do SDL_mixeru ukazatel. V callbacku nikdy nevolejte SDL_mixer funkce ani SDL_LockAudio().</p>

<pre>
void Mix_HookMusic(void (*mix_func)(void *udata,
		Uint8 *stream, int len), void *arg);
</pre>

<p>Parametry jsou v podstatì stejné jako u SDL callback funkce, do udata se bude pøedávat ukazatel z arg. Ten se také dá kdykoli zjistit pomocí Mix_GetMusicHookData().</p>

<pre>
void *Mix_GetMusicHookData();
</pre>

<p>Následující tøi funkce slou¾í pro zmìnu hlasitosti, pozastavení a následné obnovení pøehrávání.</p>

<pre>
int Mix_VolumeMusic(int volume);
void Mix_PauseMusic();
void Mix_ResumeMusic();
</pre>

<p>Funkci Mix_RewindMusic() lze pou¾ít pro skok na zaèátek hudby, ale pracuje pouze s typy .MOD, .OGG, .MP3 a nativním .MIDI.</p>

<pre>
void Mix_RewindMusic();
</pre>

<p>Pokud je to mo¾né, pak Mix_SetMusicPosition() skoèí na libovolné místo hudby, v pøípadì úspìchu vrátí 0, neúspìch oznamuje -1 (vìt¹inou zpùsobeno nepodporováním v dekodéru). Parametr position je závislý na typu zdroje, napøíklad u .OGG má význam pozice od zaèátku, ale u .MP3 je vzta¾en k aktuální pozici. Obì hodnoty jsou mìøeny v sekundách.</p>

<pre>
int Mix_SetMusicPosition(double position);
</pre>

<p>Jedním z tìch zajímavìj¹ích pøíkazù je Mix_SetMusicCMD(), který umo¾òuje pou¾ít pro pøehrávání hudby libovolný pøehrávaè nainstalovaný v systému. Za parametr by mìl být pøedán kompletní pøíkaz, jako kdyby se psal do pøíkazové øádky, na konec bude automaticky dosazeno jméno souboru s hudbou. Pro návrat zpìt k internímu pøehrávaèi staèí za parametr pøedat hodnotu NULL. Pøi úspìchu je vrácena nula, jinak -1.</p>

<pre>
int Mix_SetMusicCMD(const char *command);
</pre>

<p>Aby se dala hudba korigovat, musí daný pøehrávaè podporovat ovládání pomocí signálù SIGTERM (zastavení), SIGSTOP (pauza) a SIGCONT (obnovení). Zmìna hlasitosti nemá u externího pøehrávaèe ¾ádný efekt, smyèky lze implementovat opakovaným spou¹tìním. Tento pøíkaz není úplnì portovatelný!</p>

<p>Následující ukázka je pøevzata z dokumentace SDL_mixeru.</p>

<pre>
Mix_Music *music = NULL;

if(Mix_SetMusicCMD("mpg123 -q") == -1)
{
	perror("Mix_SetMusicCMD");
}
else
{
	music = Mix_LoadMUS("music.mp3");
	if(music)
		Mix_PlayMusic(music, 1);
}
</pre>

<p>Pøehrávání se dá zastavit funkcemi Mix_HaltMusic() a Mix_FadeOutMusic(). Pomocí tøetí uvedené funkce lze pøedat do SDL_mixeru ukazatel na libovolnou callback funkci daného typu, která se automaticky spustí po zastavení hudby. Opìt by se v ní nemìly objevit ¾ádné SDL_mixer pøíkazy ani SDL_LockAudio().</p>

<pre>
int Mix_HaltMusic();
int Mix_FadeOutMusic(int ms);
void Mix_HookMusicFinished(void (*music_finished)());
</pre>

<p>Zdrojový formát hudby se dá zjistit voláním funkce Mix_GetMusicType(), která vrátí jednu z konstant MUS_NONE, MUS_CMD, MUS_WAV, MUS_MOD, MUS_MID, MUS_OGG, MUS_MP3. Za parametr se mù¾e pøedat libovolný objekt s hudbou, u NULL se pøedpokládá dotaz na právì pøehrávanou.</p>

<pre>
Mix_MusicType Mix_GetMusicType(const Mix_Music *music);
</pre>

<p>Pou¾ití tohoto pøíkazu je výhodné napøíklad spolu s Mix_SetMusicPosition() a podobnými funkcemi, které se s rùznými typy chovají odli¹nì.</p>

<p>A opìt nezbytné funkce na dotazy...</p>

<pre>
int Mix_PlayingMusic();
int Mix_PausedMusic();
Mix_Fading Mix_FadingMusic();
</pre>


<h2>Efekty</h2>

<p>Následující funkce vykonávají na audio výstupu speciální efekty. Lze je pou¾ít buï výhradnì na jeden kanál, pak se za první parametr dosazuje jeho èíslo, nebo na kompletní zvukový výstup, tj. v¹echny kanály + hudba (tzv. postefekt), k tomu slou¾í symbolická konstanta MIX_CHANNEL_POST.</p>

<p>Je dùle¾ité si uvìdomit, ¾e pou¾ívání efektù zvy¹uje relativnì velkou mìrou nároènost aplikace. Napøíklad prohození levého a pravého stereo kanálu na výstupu za to vùbec nemusí stát, zamìnìní bednièek na stole bude rozhodnì efektivnìj¹í. Nìkteré interní efekty mohou, v pøípadì, ¾e je definována systémová promìnná MIX_EFFECTSMAXSPEED, sní¾it svou nároènost, ale zároveò i kvalitu.</p>

<p> V¹echny funkce pro efekty vracejí pøi chybì nulu, u¾ to nebude dále uvádìno.</p>

<p>Jedním ze základních efektù je definice rozdílné hlasitosti levého a pravého kanálu funkcí Mix_SetPanning(). Hlasitost se tentokrát specifikuje v rozmezí od 0 do 255.</p>

<pre>
int Mix_SetPanning(int channel, Uint8 left, Uint8 right);
</pre>

<p>Tento efekt pracuje výhradnì ve stereo re¾imu. Aby byla celková hlasitost v¾dy stejná, je dobré oznaèit jednu hodnotu za referenèní a druhou k ní vztáhnout, jako je to ukázáno na následujícím pøíkladu.</p>

<pre>
// Optimální nastavení hlasitosti
Mix_SetPanning(channel, left, 255 - left);
</pre>

<p>Pøedání hlasitostí 255 za obì hodnoty bude mít za následek odregistrování (vypnutí) efektu.</p>

<p>Pomocí funkce Mix_SetDistance() lze simulovat zmìnu hlasitosti v závislosti na vzdálenosti posluchaèe od zdroje zvuku. Za parametr distance se dosazují hodnoty od 0 (nejblí¾e, nejhlasitìji) do 255 (nejdále, nejti¹eji). I z nejvìt¹í vzdálenosti bude zvuk trochu sly¹et.</p>

<pre>
int Mix_SetDistance(int channel, Uint8 distance);
</pre>

<p>Velice jednoduchý 3D zvuk lze emulovat funkcí Mix_SetPosition(). Pro parametr urèující vzdálenost platí stejná pravidla, jako u Mix_SetDistance(). Úhel se definuje ve stupních v rozmezí plného úhlu, èili 360 stupòù. Èíslo 0 odpovídá zvuku zepøedu, 90 zprava, 180 zezadu a 270 zleva, mezihodnoty jsou samozøejmì mo¾né, nicménì blízké hodnoty (podle dokumentace 1-7, 8-15 atd.) budou mít stejné úèinky.</p>

<pre>
int Mix_SetPosition(int channel,
		Sint16 angle, Uint8 distance);
</pre>

<p>Pøedáním nuly za úhel i vzdálenost se efekt odregistruje. Mimochodem, pokud hledáte komplexnìj¹í techniky pro 3D audio, mù¾ete zkusit napøíklad knihovnu OpenAL, rozhraním se velice podobá grafické OpenGL.</p>

<p>Funkcí Mix_SetReverseStereo() lze docílit prohození levého a pravého kanálu, nicménì zamìnìní bednièek na stole bude mnohem ménì nároèné. Za flip je mo¾né dosadit libovolnou nenulovou hodnotu, nulou se efekt odregistruje.</p>

<pre>
int Mix_SetReverseStereo(int channel, int flip);
</pre>

<p>Kromì pøeddefinovaných efektù, které byly právì popsány, poskytuje SDL_mixer rozhraní pro tvorbu libovolných nových. V podstatì staèí napsat dvì funkce a zaregistrovat je. Právì probrané interní efekty pracují naprosto stejným zpùsobem.</p>

<p>První z funkcí, které je potøeba naprogramovat, vykonává samotný efekt. SDL_mixer jí bude v parametrech pøedávat èíslo kanálu, na nìm¾ je provádìna, ukazatel na buffer se zvukovými daty, jejich délku a u¾ivatelský parametr. Úkolem je v podstatì naèíst data ze streamu, nìjakým zpùsobem je upravit a vlo¾it je zpìt.</p>

<pre>
typedef void (*Mix_EffectFunc_t)(int chan, void *stream,
		int len, void *udata);
</pre>

<p>Mìjte na pamìti, ¾e data ve streamu u¾ nejsou ve formátu specifikovaném v Mix_OpenAudio(), ale ve formátu zvukového zaøízení, ten sice mù¾e, ale nemusí být stejný. Pro zji¹tìní aktuálnì pou¾ívaného formátu slou¾í funkce Mix_QuerySpec().</p>

<p>Druhá u¾ivatelská funkce se volá, kdy¾ kanál dokonèil pøehrávání, byl zastaven nebo dealokován, popø. efekt byl odregistrován. Jejím úkolem je napøíklad resetovat interní promìnné nebo uvolnit dynamickou pamì». Pokud nic z toho není potøeba, je mo¾né pøedávat místo ní hodnotu NULL.</p>

<pre>
typedef void (*Mix_EffectDone_t)(int chan, void *udata);
</pre>

<p>Efekt se registruje funkcí Mix_RegisterEffect(). Pøedává se jí èíslo kanálu, ukazatele na funkce, které budou efekt vykonávat, a ukazatel na u¾ivatelská data. Na jeho adresu se napøíklad mohou ukládat stavové parametry.</p>

<pre>
int Mix_RegisterEffect(int chan, Mix_EffectFunc_t f,
		Mix_EffectDone_t d, void *arg);
</pre>

<p>Efekty jsou vnitønì realizovány jako spojový seznam, pøi registrování se v¾dy vkládají na konec a v¾dy se spou¹tí nad výstupy svých pøedchùdcù. Nic nebrání tomu, aby byl jeden efekt registrován vícekrát, v takovém pøípadì se úèinky kumulují.</p>

<p>Po ukonèení pøehrávání je v¾dy spojový seznam daného kanálu resetován. Pøi ka¾dém volání Mix_PlayChannel*() je tedy nutné v¹echny efekty opìtovnì zaregistrovat.</p>

<p>Pomocí Mix_UnregisterEffect() lze libovolný efekt odregistrovat, pøedává se jí ukazatel na vykonávací funkci. Stejný ukazatel se hledá ve spojovém seznamu a odstranìn je v¾dy první nalezený výskyt, ostatní zùstávají zachovány.</p>

<pre>
int Mix_UnregisterEffect(int channel, Mix_EffectFunc_t f);
</pre>

<p>Funkce vrátí nulu napøíklad, pokud není kanál validní nebo nebyl efekt registrován. Pokud tedy chcete odregistrovat v¹echny efekty daného typu, není nic jednodu¹¹ího, ne¾ vlo¾it volání této funkce do cyklu.</p>

<p>Úplnì v¹echny efekty aplikované na kanál lze odregistrovat funkcí Mix_UnregisterAllEffects(), pøi jakékoli chybì je opìt vrácena nula.</p>

<pre>
int Mix_UnregisterAllEffects(int channel);
</pre>

<p>Funkce Mix_SetPostMix() je v podstatì analogií Mix_RegisterEffect(MIX_CHANNEL_POST, ...), ale aplikuje se a¾ na kompletní zvukový výstup, tedy po v¹ech efektech registrovaných klasickou cestou, smixování zvukových kanálù a hudby dohromady a v¹ech postefektech. Ihned po vykonání se stream posílá na audio zaøízení, tak¾e pokud plánujete implementovat grafické vizualizace, jste na správném místì.</p>

<pre>
void Mix_SetPostMix(void (*mix_func)(void *udata,
		Uint8 *stream, int len), void *arg);
</pre>

<p>Èinnost callback funkce neskonèí, dokud není audio zaøízení zavøeno nebo není místo mixovací funkce pøedáno NULL.</p>


<h2>Skupiny kanálù</h2>

<p>Mo¾ná vám bude pøipadat seskupování kanálù relativnì zbyteèné, ale v nìkterých pøípadech se mù¾e teoreticky hodit. Díky nìmu lze aplikovat operace, jako je pauza nebo zastavení, na v¹echny kanály v dané skupinì. Mimochodem s jednou skupinou jsme se u¾ setkali, mìla èíslo -1 a obsahovala v¹echny kanály.</p>

<p>Pøi popisu funkcí typu Mix_PlayChannel(), jsme si øekli, ¾e se pøi zadání parametru -1 pou¾ije libovolný volný kanál. Funkcí Mix_ReserveChannels() se rezervují kanály, aby je nebylo mo¾no takto náhodnì vybrat.</p>

<pre>
int Mix_ReserveChannels(int num);
</pre>

<p>Za parametr se pøedává po¾adovaný poèet kanálù, ty se rezervují od nuly do num-1. Pøedání nuly rezervaci zru¹í. Návratovou hodnotou je poèet opravdu rezervovaných kanálù, ten mù¾e být v závislosti na poètu alokovaných men¹í, ne¾ je po¾adováno.</p>

<p>Pøidání kanálu do skupiny se vykoná voláním funkce Mix_GroupChannel(). První parametr oznaèuje kanál a druhý jméno skupiny, mù¾e jím být libovolné kladné èíslo vèetnì nuly. Opaèný smìr, tj. odebrání ze skupiny, se provede zadáním -1, v podstatì se kanál vlo¾í do globální. Druhá funkce operuje nad více po sobì jdoucími kanály najednou.</p>

<pre>
int Mix_GroupChannel(int which, int tag);
int Mix_GroupChannels(int from, int to, int tag);
</pre>

<p>První z funkcí vrací pøi úspìchu 1 a pøi neúspìchu 0, druhá poèet pøidaných kanálù. Poèet kanálù ve skupinì se dá zjistit funkcí Mix_GroupCount().</p>

<pre>
int Mix_GroupCount(int tag);
</pre>

<p>První dostupný/nehrající kanál ve skupinì lze najít voláním funkce Mix_GroupAvailable(). Mix_GroupOldest() slou¾í pro nalezení momentálnì nejdéle hrajícího kanálu a Mix_GroupNewer() hledá nejnovìj¹í.</p>

<pre>
int Mix_GroupAvailable(int tag);
int Mix_GroupOldest(int tag);
int Mix_GroupNewer(int tag);
</pre>

<p>V pøípadì, ¾e není ¾ádný kanál nalezen je vráceno èíslo -1.</p>

<p>Odeznívání a následné ukonèení pøehrávání kanálù sdru¾ených do skupiny lze provést pomocí Mix_FadeOutGroup(), èas se opìt zadává v milisekundách. Druhá uvedená funkce zpùsobí okam¾ité zastavení.</p>

<pre>
int Mix_FadeOutGroup(int tag, int ms);
int Mix_HaltGroup(int tag);
</pre>


<h2>Ukázkové programy</h2>

<h3>Hudba a efekty</h3>

<p>Program demonstruje pøehrávání hudby a hlavnì zabudované efekty v SDL_mixeru. Cesta k hudbì se pøedává jako parametr programu. Ovládání:</p>

<ul>
<li>[+/-] - hlasitost</li>
<li>[mezerník] - prohodí levý a pravý kanál</li>
<li>[¹ipka doleva/doprava] - výstup z levého/pravého kanálu</li>
<li>[¹ipka nahoru/dolù] - vzdálenost od zdroje zvuku</li>
<li>[1,2,3,4,6,7,8,9] - pozice zdroje zvuku (úhel)</li>
</ul>

<p><a href="./src/sdl_20_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>


<h3>Zvuky ve høe</h3>

<p>Program roz¹iøuje ukázkový pøíklad ze <a href="sdl_16.html">16. dílu</a> (hra ve stylu Pacmana). Do scény jsou pøidány objekty, které má hráè za úkol sbírat (reset pomocí R) a nìjaké ty zvuky. Hudba je volitelná, staèí odkomentovat jedno define a nastavit cestu k libovolnému souboru. <a href="./src/sdl_20_b.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/20_prog_b.png" width="322" height="259" alt="Zvuky ve høe" /></div>


<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_20_a.tar.gz">Pøíklad: Hudba a efekty</a></li>
<li><a href="./src/sdl_20_b.tar.gz">Pøíklad: Zvuky ve høe</a></li>
<li><a href="sdl_20.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>To bylo ze SDL_mixeru v¹e, v pøí¹tím díle se budeme vìnovat pøehrávání hudby z CD.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 30.06.2005</div>

</body>
</html>
