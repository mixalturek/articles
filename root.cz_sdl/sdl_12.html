<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (12)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (12)</h1>

<p class="perex">Pravdìpodobnì nejpou¾ívanìj¹ími vstupními zaøízeními poèítaèe jsou klávesnice a my¹, v na¹em seriálu zaèneme právì klávesnicí. Podíváme se na ni jak z událostního pohledu, tak &quot;pøímým&quot; pøístupem a udìláme první krok k interaktivním hrám.</p>


<h2>Události klávesnice</h2>

<p>SDL definuje pro klávesnici dvì události, první je generována, kdy¾ u¾ivatel stiskne klávesu, a druhá, kdy¾ ji uvolní. Parametr type objektu SDL_Event je v takovém pøípadì nastaven na hodnotu SDL_KEYDOWN resp. SDL_KEYUP a podrobnosti o události jsou ulo¾eny do promìnné key, co¾ je objekt struktury SDL_KeyboardEvent.</p>

<pre>
typedef struct
{
	Uint8 type;
	Uint8 state;
	SDL_keysym keysym;
} SDL_KeyboardEvent;
</pre>

<p>Jak u¾ bylo øeèeno, type obsahuje buï hodnotu SDL_KEYDOWN nebo SDL_KEYUP. Atribut state nese naprosto stejnou informaci, ale pou¾ívá pro to jména SDL_PRESSED a SDL_RELEASED, jinak ¾ádný rozdíl.</p>

<p>Poslední z uvedených atributù je struktura SDL_keysym poskytující informace o stisknuté klávese. Je definována následovnì.</p>

<pre>
typedef struct
{
	Uint8 scancode;
	SDLKey sym;
	SDLMod mod;
	Uint16 unicode;
} SDL_keysym;
</pre>

<p>Scancode pøedstavuje scankód, který pochází pøímo od hardwaru, ale v praxi se v podstatì nepou¾ívá.</p>

<p>Naproti tomu promìnná sym, odvozená od SDLKey, je pou¾ívána velice èasto, nese v sobì symbolické jméno stisknuté klávesy. Promìnná mod oznamuje pøítomnost modifikátorù, jako jsou shift, ctrl, alt atd. Souèasným zkoumáním sym a mod, lze tedy velice snadno implementovat klávesové zkratky.</p>

<p>Poslední polo¾ka obsahuje, pokud jsou pøeklady zapnuté, hodnotu klávesy/znaku v kódování unicode.</p>

<p>V¹echny uvedené skuteènosti budou podrobnì rozebrány v následujícím textu...</p>


<h2>Symbolická jména kláves</h2>

<p>SDLKey je v hlavièkovém souboru SDL_keysym.h deklarováno jako výètový typ, který definuje symbolická jména jednotlivých kláves. Znaky z první poloviny ASCII tabulky (do 127) jsou namapovány na odpovídající klávesy na klávesnici. Z toho plyne, ¾e konstanta SDLK_a mù¾e být pøi porovnávání parametru sym nahrazena obyèejným znakem 'a' a podobnì.</p>

<p>V¹echna symbolická jména kláves zaèínají na pøedponu 'SDLK_', za kterou následuje vlastní název - SDLK_SPACE (mezerník), SDLK_RETURN (enter), SDLK_UP (¹ipka nahoru), SDLK_F1 (funkèní klávesa F1), atd. Nejrozumnìj¹í asi bude, kdy¾ si tato jména najde ka¾dý sám v SDL dokumentaci. Dole v hlavním menu je umístìn odkaz <a href="http://sdldoc.csn.ul.ie/sdlkey.php">8-1. SDL Keysym definitions</a>.</p>

<p>Na stejném místì lze nalézt i definice modifikátorù z parametru mod, jejich názvy zaèínají na 'KMOD_' a pøi testech se v¾dy vyu¾ívá funkce bitového souèinu (AND). Jeliko¾ je jich jen nìkolik, uvedeme si je i do textu èlánku. Mimochodem, stejným zpùsobem jako SDLMod je definován i SDLKey.</p>

<pre>
typedef enum
{
	KMOD_NONE  = 0x0000,
	KMOD_LSHIFT= 0x0001,
	KMOD_RSHIFT= 0x0002,
	KMOD_LCTRL = 0x0040,
	KMOD_RCTRL = 0x0080,
	KMOD_LALT  = 0x0100,
	KMOD_RALT  = 0x0200,
	KMOD_LMETA = 0x0400,
	KMOD_RMETA = 0x0800,
	KMOD_NUM   = 0x1000,
	KMOD_CAPS  = 0x2000,
	KMOD_MODE  = 0x4000,
} SDLMod;

#define KMOD_CTR   (KMOD_LCTRL|KMOD_RCTRL)
#define KMOD_SHIFT (KMOD_LSHIFT|KMOD_RSHIFT)
#define KMOD_ALT   (KMOD_LALT|KMOD_RALT)
#define KMOD_META  (KMOD_LMETA|KMOD_RMETA)
</pre>

<p>Na následujícím pøíkladu se implementuje klávesová zkratka (levý)Alt+Enter, jejím¾ výsledkem bude pøepnutí okna do fullscreenu.</p>

<pre>
// Zpracování událostí, stisk klávesy
case SDLK_RETURN:
	if(event.key.keysym.mod & KMOD_LALT)
		if(!ToggleFullscreen())
			return false;
	break;
</pre>

<p>Pozn.: Funkce ToggleFullscreen() byla naprogramována v minulém dílu tohoto seriálu.</p>


<h2>Unicode znaky</h2>

<p>Na chvíli se je¹tì vrátíme zpìt k SDL_keysym. Pokud je parametr unicode v této struktuøe nenulový, pak obsahuje unicode znak, který odpovídá stisknuté klávese a je-li navíc horních devìt bitù nulových, bude ekvivalentní ASCII znaku (16 - 9 = 7 ;-). SDL dokumentace obsahuje pøíklad demonstrující obsah tohoto odstavce.</p>

<pre>
char ch;
if((keysym.unicode &amp; 0xFF80) == 0)
	ch = keysym.unicode &amp; 0x7F;
else
	printf("Mezinárodní znak.\n");
</pre>

<p>Jeliko¾ jsou pøeklady znakù do unicode relativnì výkonovì nároèné, jsou v SDL standardnì vypnuté. Jednièka, pøedaná do SDL_EnableUNICODE(), podporu zapíná, nula vypíná a mínus jednièky mù¾e být vyu¾ito k dotazùm.</p>

<pre>
int SDL_EnableUNICODE(int enable);
</pre>


<h2>Opakování událostí pøi dr¾ení klávesy</h2>

<p>Windows programátory by po spu¹tìní ukázkových pøíkladù mohlo teoreticky pøekvapit, ¾e stisk klávesy, její déletrvající dr¾ení a uvolnìní, zpùsobí vygenerování V®DY DVOU událostí - zprávy o stisku a následnì zprávy o uvolnìní, nic dal¹ího.</p>

<p>Ve Win32 API se narozdíl od SDL první zpráva WM_KEYDOWN (analogie SDL_KEYDOWN) po¹le aplikaci pøi stisku a pokud je klávesa dr¾ena del¹í dobu, následují po urèitém èasovém intervalu zprávy dal¹í.</p>

<p>SDL mù¾e být po¾ádáno, aby se chovalo stejným zpùsobem. Slou¾í k tomu funkce SDL_EnableKeyRepeat(), její¾ parametr delay øíká, za jak dlouho se má od stisku poslat první opakovací zpráva (èili druhá SDL_KEYDOWN v poøadí) a parametr interval specifikuje periodu odesílání následujících zpráv. Obì hodnoty jsou v jednotkách milisekund.</p>

<pre>
int SDL_EnableKeyRepeat(int delay, int interval);
</pre>

<p>Pøedání nuly do delay zpùsobí vypnutí opakování, co¾ je v SDL implicitní stav. Místo zadání konkrétních hodnot, je mo¾né èasy specifikovat také symbolickými konstantami SDL_DEFAULT_REPEAT_DELAY a SDL_DEFAULT_REPEAT_INTERVAL. Funkce pøi úspìchu vrátí 0, jinak -1.</p>


<h2>&quot;Pøímý&quot; pøístup ke klávesnici</h2>

<p>Pøi programování her vzniká relativnì èasto potøeba dotázat se kdykoli v programu, zda je urèitá klávesa stisknutá nebo ne. Události jsou v tomto pøípadì nepou¾itelné, proto¾e neinformují o aktuálním stavu, ale jen o jeho zmìnách. Proto lze v nìkterých zdrojových kódech najít konstrukce podobné tìm na následujícím výpise.</p>

<pre>
// Globální pole indikátorù klávesnice
// V Init() nastavit v¹echny polo¾ky na false
bool g_keys[MAX_KEYS];

// Události stisku a uvolnìní
case SDL_KEYDOWN:
	// Nastavit indikátor dané klávesy
	g_keys[event.key.keysym.sym] = true;
	break;

case SDL_KEYUP:
	// Vynulovat indikátor dané klávesy
	g_keys[event.key.keysym.sym] = false;
	break;

// Zji¹tìní stisku klávesy
if(g_keys[SDKL_UP])
	JdiNahoru(g_fps);
else
	NicNedelej();
</pre>

<p>Pozn.: Velikost globálního pole g_keys jsme definovali jako MAX_KEYS indikátorù. V nìkterých knihovnách je zvykem jeho rozsah definovat na 256, nicménì letmý pohled do SDL_keysym.h uká¾e, ¾e tuto konstantu v SDL pou¾ít nelze, definovaných kláves je víc.</p>

<p>Po krátkém hledání mù¾eme v SDL objevit funkci SDL_GetKeyState(), je¾ vrací ukazatel na vnitøní pole indikátorù klávesnice (analogie na¹eho g_keys), které mù¾e být indexováno SDLK_* symboly. Není-li parametr funkce nastaven na NULL, SDL do nìj vlo¾í velikost tohoto pole.</p>

<pre>
Uint8 *SDL_GetKeyState(int *numkeys);</p>
</pre>

<p>Jednièková hodnota na indexu oznamuje, ¾e je klávesa stisknutá, v pøípadì nuly není. Lze také pou¾ít symbolické konstanty SDL_PRESSED a SDL_RELEASED. Pøed samotnými dotazy na klávesy mù¾e být vhodné funkcí SDL_PumpEvents() (viz minulý díl) informace v poli aktualizovat.</p>

<p>Pøepis kódu vý¹e do SDL by tedy mohl vypadat následovnì.</p>

<pre>
// Zji¹tìní stisku klávesy
SDL_PumpEvents();

Uint8* keys;
keys = SDL_GetKeyState(NULL);

if(keys[SDLK_UP] == SDL_PRESSED)
	JdiNahoru(g_fps);
else
	NicNedelej();
</pre>

<p>Pomocí SDL_GetKeyState() je samozøejmì mo¾né zjistit i pøítomnost modifikátorù, vìt¹inou se v¹ak vyu¾ívá slu¾eb specializované funkce SDL_GetModState(). V jejím pøípadì není vrácen ukazatel na pole, ale bitová maska.</p>

<pre>
SDLMod SDL_GetModState(void);
void SDL_SetModState(SDLMod modstate);
</pre>

<p>Pomocí druhé uvedené funkce lze pro program klávesu modifikátoru virtuálnì stisknout.</p>


<h2>Kdy pou¾ít události a kdy pøímý pøístup</h2>

<p>Zkusíme, podobnì jako u událostí vý¹e, definovat klávesovou zkratku Alt+Enter pro pøepnutí okna do fullscreenu a pak si vysvìtlíme, proè není tento kód obecnì pou¾itelný.</p>

<pre>
// Tento kód není obecnì pou¾itelný!!!

if(keys[SDLK_RETURN] == SDL_PRESSED)
	if(SDL_GetModState() & KMOD_LALT)
		if(!ToggleFullscreen())
			return false;
</pre>

<p>Výpis je ve svém principu naprosto správný, ale po zobrazení kompletního zdrojového kódu kterékoli z ukázkových aplikací zjistíme, ¾e samotný test klávesové zkratky a tedy i pøepnutí do fullscreenu je vlo¾eno do hlavního cyklu aplikace, který se provádí neustále dokola.</p>

<p>Øeknìme, ¾e se právì teï nacházíme ve fullscreenu a chceme se pøepnout do okna. Kód správnì detekuje Alt+Enter a zmìní stav. Problém je, ¾e za nìkolik milisekund (po vykreslení a aktualizaci scény) nastane dal¹í prùchod cyklem a u¾ivatel stále dr¾í Alt+Enter. Tak¾e se aplikace opìt pøepne, tentokrát zpìt do fullscreenu. To se bude opakovat neustále dokola, dokud budou obì klávesy stisknuté. Po uvolnìní navíc není urèen výsledek.</p>

<p>Uvedeme si je¹tì jeden obecnì nepou¾itelný pøíklad.</p>

<pre>
// Tento kód není obecnì pou¾itelný!!!

// Zpracování událostí klávesnice
case SDLK_UP:
	JdiNahoru(g_fps);
	break;
</pre>

<p>Co se stane teï? Kdy¾ u¾ivatel stiskne ¹ipku nahoru, postavièka ve høe se posune o pár pixelù nahoru, ale pak zùstane stát. Pøi libovolnì dlouhém dr¾ení klávesy pøijde jen jedna zpráva o stisku.</p>

<p>Z pøíkladù vý¹e tedy jasnì vyplývá, ¾e na rùzné pohyby postavièek po scénì je vhodné pou¾ívat pøímý pøístup ke klávesnici (rychlost pohybù vztahovat k aktuálnímu FPS) a pøepínání nejrùznìj¹ích flagù o¹etøovat událostmi. Obecnou platnost této pouèky trochu nabourává funkce SDL_EnableKeyRepeat(), ale pokud se jí budeme dr¾et, nemìly by nastat ¾ádné problémy...</p>


<h2>Øetìzec se jménem klávesy</h2>

<p>Nìkdy mù¾e být potøebné zjistit jméno stisknuté klávesy. V SDL je to s pomocí funkce SDL_GetKeyName() velice snadné. Za parametr se pøedává symbolické jméno klávesy a výstupem je øetìzec ukonèený NULL.</p>

<pre>
char *SDL_GetKeyName(SDLKey key);
</pre>

<p>Následující kód by ve spu¹tìném programu zajistil výpisy jmen stisknutých kláves. Pro jednoduchost je uveden jen výpis do konzole, ale kdyby se text zobrazoval graficky do okna (napø. s pomocí SDL_ttf), mìli bychom k dispozici základní GUI výbìru kláves pro ovládání hry.</p>

<pre>
// Zpracování událostí, stisk klávesy
case SDL_KEYDOWN:
	printf("%s\n", SDL_GetKeyName(
			event.key.keysym.sym));
	break;
</pre>

<p>Výstup by po nìkolika úderech na klávesnici vypadal nìjak takto:</p>

<pre>
space		// Mezerník
return		// Enter
caps lock
left shift
left ctrl
f		// Písmeno f
down		// ©ipka dolù
...
</pre>


<h2>Ukázkové programy</h2>

<h3>Odrazy</h3>

<p>Ukázkový program vykresluje objekt, se kterým je mo¾no pomocí ¹ipek (pøímý pøístup) pohybovat. Stisk nemìní polohu pøímo, ale je jím ovlivnìno zrychlení, v ka¾dém prùchodu je pozice zvìt¹ována o rychlost. Také je aplikována gravitace. V pøípadì, ¾e objekt narazí do stìny (okraj okna), odrazí se a jeho rychlost je o nìco zmen¹ena.</p>

<p>Jako bonus byl v programu implementován pomocí událostí i jeden cheat. Na klávesnici se na»uká posloupnost &quot;cheat&quot; a co se stane, uvidíte po spu¹tìní ;-). <a href="./src/sdl_12_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/12_prog_a.png" width="322" height="259" alt="Odrazy" /></div>

<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_12_a.tar.gz">Pøíklad: Odrazy</a></li>
<li><a href="sdl_02.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Podobným zpùsobem, jako byla dnes probrána klávesnice, se budeme pøí¹tì vìnovat práci s my¹í.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 12.04.2005</div>

</body>
</html>
