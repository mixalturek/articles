<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (6)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (6)</h1>

<p class="perex">V tomto dílu budeme dále rozvíjet na¹e znalosti o SDL grafice. Pøedvedeme si napøíklad, jak vyplnit surface barvou, jak docílit toho, aby urèitá barva byla transparentní (prùhledná), jak nastavit prùhlednost i takového surface, který neobsahuje alfa kanál, a dal¹í u¾iteèné vìci.</p>


<h2>Vytvoøení prázdného surface</h2>

<p>Prázdný SDL_Surface se dá v programu vytvoøit pomocí funkce SDL_CreateRGBSurface(). První ètyøi parametry jistì není tøeba popisovat, jsou jimi flagy, ¹íøka, vý¹ka a barevná hloubka. Bity masek definují poøadí barevných slo¾ek v pixelu, oznaèují tedy, jestli bude obrázek ulo¾en jako RGB, BGR popø. v jiném formátu. U osmi a ètyø bitové barevné hloubky bude alokována prázdná paleta.</p>

<pre>
SDL_Surface *SDL_CreateRGBSurface(Uint32 flags,
		int width, int height, int depth,
		Uint32 Rmask, Uint32 Gmask,
		Uint32 Bmask, Uint32 Amask);

SDL_Surface *SDL_CreateRGBSurfaceFrom(void *pixels,
		int width, int height, int depth, int pitch,
		Uint32 Rmask, Uint32 Gmask,
		Uint32 Bmask, Uint32 Amask);
</pre>

<p>Pøi vytváøení surface je vhodné specifikovat masky v závislosti na poøadí bytù, které se pou¾ívá na dané platformì (little/big endian). SDL definuje symbolickou konstantu SDL_BYTEORDER, je¾ se rovná buï hodnotì SDL_LIL_ENDIAN, nebo SDL_BIG_ENDIAN.</p>

<p>Napøíklad pøi vytváøení textury pro OpenGL je vhodné podle následujícího pøíkladu vytvoøit pomocný surface, voláním SDL_Blit() do nìj pixely zkopírovat, tím se transformují do správného formátu, a a¾ poté vytvoøit texturu.</p>

<pre>
SDL_Surface *surface = SDL_CreateRGBSurface(
		SDL_SWSURFACE,
		128, 128, 32,
#if SDL_BYTEORDER == SDL_LIL_ENDIAN
		0x000000FF,
		0x0000FF00,
		0x00FF0000,
		0xFF000000
#else
		0xFF000000,
		0x00FF0000,
		0x0000FF00,
		0x000000FF
#endif
		);
</pre>


<h2>Oøezávací obdélník surface</h2>

<p>Pøíkazem SDL_SetClipRect() lze surface &quot;virtuálnì oøezat&quot;, pro funkce se pak bude chovat, jako by mìl definovánu tuto novou velikost. Maximální rozmìry mohou být následnì obnoveny pøedáním NULL. Uvedená vlastnost se bere v úvahu, kdy¾ se do surface kreslí, ne kdy¾ je kreslen!</p>

<p>Pokud funkce vrátí SDL_FALSE, obdélník neprotínal surface a pøi vykreslování se tedy nezobrazí nic. Zasahuje-li alespoò èást obdélníku do surface, je vráceno SDL_TRUE a pøi kreslení se bude brát v úvahu oblast prùniku.</p>

<pre>
SDL_bool SDL_SetClipRect(SDL_Surface *surface, SDL_Rect *rect);
void SDL_GetClipRect(SDL_Surface *surface, SDL_Rect *rect);
</pre>

<p>Pomocí druhé uvedené funkce lze získat aktuální oøezávací roviny obdélníku.</p>


<h2>Specifikace barvy</h2>

<p>Kvùli mnoha rùzným formátùm surface - zvlá¹tì paletovým - mù¾e být výbìr barvy komplikovanìj¹í, ne¾ by se na první pohled mohlo zdát. Na¹tìstí SDL poskytuje pøíkazy, které se umí postarat o v¹echny detaily.</p>

<pre>
Uint32 SDL_MapRGB(SDL_PixelFormat *fmt,
		Uint8 r, Uint8 g, Uint8 b);
Uint32 SDL_MapRGBA(SDL_PixelFormat *fmt,
		Uint8 r, Uint8 g, Uint8 b, Uint8 a);
</pre>

<p>První parametr funkce je formátem pixelù, který daný surface pou¾ívá (vìt¹inou surface->format), a ostatní pøedstavují jednotlivé RGB(A) slo¾ky. Barva je vrácena jako 32-bitové èíslo, jen¾ je buï pøímo po¾adovanou barvou, nebo, v pøípadì paletového pixel formátu, barvou která se nachází v paletì a nejvíce se blí¾í po¾adované.</p>

<p>Opaèný smìr, tedy získání RGB(A) slo¾ek barvy z pixelu, zprostøedkovávají funkce</p>

<pre>
void SDL_GetRGB(Uint32 pixel, SDL_PixelFormat *fmt,
		Uint8 *r, Uint8 *g, Uint8 *b);
void SDL_GetRGBA(Uint32 pixel, SDL_PixelFormat *fmt,
		Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
</pre>


<h2>Vyplnìní surface barvou</h2>

<p>Funkce SDL_FillRect() se vìt¹inou pou¾ívá ke zmìnì barvy pozadí okna, ale lze ji pou¾ít na libovolný surface.</p>

<pre>
int SDL_FillRect(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color);
</pre>

<p>První parametr pøedstavuje surface, na který bude operace aplikována a druhý omezuje velikost obarvované plochy. Pokud by byl tento obdélník nastaven na NULL, pøedpokládá se vyplnìní celého surface. Color urèuje barvu.</p>

<p>Obsahuje-li surface oøezávací obdélník, bude vyplnìn pouze jeho prùnik s dstrect a dstrect bude nastaven na rozmìry vyplnìné oblasti. Následující pøíklad nastaví pozadí okna na èervenou barvu.</p>

<pre>
// Èervené pozadí okna
SDL_FillRect(g_screen, NULL, SDL_MapRGB(g_screen->format, 255, 0, 0));
</pre>


<h2>Nastavení klíèové (prùhledné) barvy</h2>

<p>Transparentní barva surface se dá nastavit pomocí funkce SDL_SetColorKey(). Pøi blittingu nebudou pixely této barvy vykresleny.</p>

<pre>
int SDL_SetColorKey(SDL_Surface *surface, Uint32 flag, Uint32 key);
</pre>

<p>Za parametr flag se pøi této operaci musí pøedat symbolická konstanta SDL_SRCCOLORKEY, pøedáním nuly se transparentní barva zru¹í. Následujícím pøíkazem se v surface zprùhlední rù¾ové pixely.</p>

<pre>
SDL_SetColorKey(surface, SDL_SRCCOLORKEY,
		SDL_MapRGB(surface->format, 255, 0, 255));
</pre>

<p>Pokud je flag binárnì ORován se SDL_RLEACCEL, bude surface vykreslován s pou¾itím RLE akcelerace. To je výhodné u spojitých oblastí prùhledných pixelù (na øádcích). Surface je pro pou¾ití RLE akcelerace zakódován pøi prvním pøedání do funkce SDL_BlitSurface() nebo SDL_DisplayFormat().</p>


<h2>Alfa hodnota surface</h2>

<p>Pomocí funkce SDL_SetAlpha() lze nastavit globální úroveò prùhlednosti, která bude aplikována na ka¾dý pixel surface.</p>

<pre>
int SDL_SetAlpha(SDL_Surface *surface, Uint32 flag, Uint8 alpha);
</pre>

<p>Parametr flag musí být nastaven na SDL_SRCALPHA a mù¾e být, stejnì jako u pøede¹lé funkce, ORován se SDL_RLEACCEL. Poslední parametr specifikuje úroveò alfy. Nula (SDL_ALPHA_TRANSPARENT) má význam úplné prùhlednosti a 255 (SDL_ALPHA_OPAQUE) znaèí neprùhlednost. Speciální hodnotou je 128, která je urèitým zpùsobem optimalizována, tak¾e blitting bude rychlej¹í ne¾ u jiných hodnot. Pøi pou¾ití této techniky nesmí mít surface alfa kanál, pou¾ila by se alfa jednotlivých pixelù.</p>


<h2>Nastavení palety</h2>

<p>Barvy v paletì osmibitového a ètyøbitového surface se dají nastavit pomocí funkce SDL_SetColors().</p>

<pre>
int SDL_SetColors(SDL_Surface *surface, SDL_Color *colors,
		int firstcolor, int ncolors);
</pre>

<p>Funkci se pøedává ukazatel na daný surface, pole barev, první barvu a celkový poèet barev. Pokud byly úspì¹nì nastaveny v¹echny barvy, je vrácena jednièka. Pokud nìkteré byly nastaveny a nìkteré ne, je vrácena nula. V takovém pøípadì by mìl programátor zjistit ze surface novì vzniklou paletu. Nejedná-li se o paletový surface, nic se neprovede a je vrácena také nula.</p>

<p>Je-li pøedaný surface asociován s oknem a byl-li v SDL_SetVideoMode() definován flag SDL_HWPALETTE, vrátí tato funkce v¾dy jednièku a nastavení palety je v¾dy garantováno.</p>

<p>V pøípadì, ¾e se jedná o framebuffer s hardwarovým surface, obsahuje v¾dy dvì palety, logickou (pou¾ívají ji funkce pro blitting) a fyzickou (pou¾ívá ji hardware k mapování na obrazovku). Aby je bylo mo¾né specifikovat oddìlenì, musí mít framebuffer nastaven ji¾ zmínìný flag SDL_HWPALETTE. K oddìlené specifikaci palet pak slou¾í funkce</p>

<pre>
int SDL_SetPalette(SDL_Surface *surface, int flags,
		SDL_Color *colors, int firstcolor,
		int ncolors);
</pre>

<p>Parametr flags mù¾e být nastaven buï na hodnotu SDL_LOGPAL (logická paleta), nebo na SDL_PHYSPAL (fyzická paleta), vìt¹inou se modifikuje pouze jedna z nich, èím¾ se dociluje rùzných efektù. Volání SDL_SetPalette() s parametrem flags nastaveným na SDL_LOGPAL | SDL_PHYSPAL je ekvivalentem SDL_SetColors().</p>

<p>V SDL manuálu se u popisu tìchto funkcí nachází pøíklad na nastavení palety úrovnì ¹edi.</p>


<h2>Ukázkové programy</h2>

<h3>Vlastnosti surface</h3>

<p>Podstata tohoto programu tkví pøedev¹ím ve vykreslovací funkci. Surface okna je zmen¹en pomocí SDL_SetClipRect() tak, aby u okrajù vznikla deseti pixelová mezera. Poté je vykresleno èervené pozadí a do ka¾dého rohu stejný obrázek, ale s jinými vlastnostmi.</p>

<p>V levém horním rohu se nachází originál tak, jak byl nahrán z disku, u obrázku vpravo je bílá barva pixelù nastavena na transparentní. Vlevo dole byla nastavena 50% prùhlednost a vpravo dole se nachází kombinace obou. Je dùle¾ité poznamenat, ¾e obrázek je ve formátu RGB, bez alfa kanálu. <a href="./src/sdl_06_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/06_prog_a.png" width="328" height="269" alt="Vlastnosti surface" /></div>


<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_06_a.tar.gz">Pøíklad: Vlastnosti surface</a></li>
<li><a href="sdl_06.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>V pøí¹tí èásti se budeme vìnovat pøímému pøístupu k pixelùm surface a zmìnì kurzoru my¹i.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 25.02.2005</div>

</body>
</html>
