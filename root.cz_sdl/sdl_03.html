<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (3)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (3)</h1>

<p class="perex">V první èásti èlánku se podíváme na konvenci názvù SDL funkcí a speciální datové typy, které SDL pøiná¹í. V druhé èásti bude popsána inicializace a deinicializace SDL.</p>


<h2>Konvence názvù SDL funkcí</h2>

<p>Knihovna SDL má jen jednoduchou konvenci pro pojmenování svých funkcí, v podstatì se jedná pouze o pøedponu SDL_. Jako pøíklad lze uvést jakoukoli funkci, napø. inicializaèní SDL_Init() se musí zavolat na zaèátku naprosto ka¾dého programu, který vyu¾ívá slu¾eb knihovny SDL.</p>

<p>Za pøedponou SDL_ se dále mù¾e nacházet WM_ nebo GL_, které oznaèuje funkci poskytující operace vztahující se ke správci oken (Window Manager) popø. týkající se knihovny OpenGL. Jako pøíklad lze uvést pøíkaz SDL_WM_ToggleFullScreen(), jen¾ pøepíná aplikaci mezi re¾imem okno/fullscreen, a SDL_GL_SwapBuffers() slou¾ící pro výmìnu pøedního a zadního bufferu po vykreslení OpenGL scény.</p>

<p>Z pøedchozích dvou pøíkladù si lze v¹imnout, ¾e tìla jmen funkcí zaèínají velkým písmenem a pokud se skládají z více slov, jsou poèáteèní písmena jednotlivých slov velká.</p>


<h2>SDL datové typy</h2>

<p>Pro dosa¾ení co nejvìt¹í pøenositelnosti kódu definuje SDL své vlastní datové typy, které se pøi deklaraci promìnných doporuèuje upøednostòovat. S jejich pou¾itím se nestane, ¾e u jiného kompilátoru nebo systému, ne¾ na kterém probíhá hlavní vývoj, bude mít nìkterý datový typ programovacího jazyka jiný rozsah. Klasickým pøíkladem je ¹estnácti a tøiceti dvou bitový int.</p>

<p>SDL definuje následující datové typy:</p>

<table>
<tr align="left"><th>Jazyk C</th>	<th>SDL</th></tr>
<tr><td>int</td>				<td>SDL_bool (SDL_FALSE, SDL_TRUE)</td></tr>
<tr><td>unsigned char</td>		<td>Uint8</td></tr>
<tr><td>unsigned short</td>		<td>Uint16</td></tr>
<tr><td>unsigned int</td>		<td>Uint32</td></tr>
<tr><td>unsigned long long</td>	<td>Uint64</td></tr>
<tr><td>signed char</td>		<td>Sint8</td></tr>
<tr><td>signed short</td>		<td>Sint16</td></tr>
<tr><td>signed int</td>			<td>Sint32</td></tr>
<tr><td>signed long long</td>		<td>Sint64</td></tr>
</table>

<p>Je nutné podotknout, ¾e 64-bitový int nemusí být podporován v¹emi platformami.</p>


<h2>Hlavièkové soubory</h2>

<p>Pøi vývoji staèí vìt¹inou vkládat pouze hlavièkový soubor SDL.h, jiné se pou¾ívají spí¹e ve speciálních nebo výjimeèných pøípadech. Osobnì jsem se dále setkal jen se SDL_opengl.h, který øe¹í umístìní knihovny OpenGL na rùzných platformách. Napø. v MacOS je k ní jiná cesta ne¾ ve Windows a Linuxu.</p>

<pre>
#include &lt;SDL.h&gt;
</pre>

<p>V zájmu pøenositelnosti by také mìla být zachována uvedená velikost písmen - tedy SDL velkými a malé h, aby ho byl case sensitive operaèní systém schopen najít. I kdy¾ se to nezdá, jedná se o docela èastý problém Windows programátorù, kteøí, kdy¾ se onehdy rozhodnou portovat svùj jinak naprosto správný program, stráví tøi hodiny nadáváním na ten ka¾dý-si-doplòte-své-slovo Linux ;-).</p>

<p>Nìkdy se lze také setkat s vkládáním hlavièkového souboru jako SDL/SDL.h, ale tento zpùsob spí¹e vytváøí problémy (/ a \ lomítko), ne¾ nìèemu pomáhá. Cestu k hlavièkovým souborùm lze nastavit ve vývojovém prostøedí.</p>


<h2>Vstup do programu</h2>

<p>®e první funkcí, kterou volá operaèní systém pøi spou¹tìní programu, je main(), ví jistì ka¾dý programátor. I pøesto, ¾e je vytváøena MS Windows aplikace, mìla by být tato funkce upøednostnìna pøed WinMain(). Pøed samotným spu¹tìním main() SDL provádí je¹tì urèité inicializace.</p>

<p>Pokud je z nìjakého dùvodu WinMain() nutná, podívejte se do souboru src/main/win32/SDL_main.c ve zdrojových kódech SDL, abyste vìdìli jaký druh dodateèné inicializace je¹tì potøebujete, aby SDL pracovalo tak, jak má.</p>

<p>Nìkteré &quot;exotické&quot; kompilátory také mohou mít problémy s formátem zápisu main(), a proto by mìla být v¾dy deklarována takto</p>

<pre>
int main(int argc, char *argv[])
</pre>


<h2>Inicializace SDL</h2>

<p>SDL se inicializuje voláním funkce</p>

<pre>
int SDL_Init(Uint32 flags);
</pre>

<p>která pøi úspìchu vrátí hodnotu 0 a pøi neúspìchu -1. Parametr flags specifikuje, co v¹echno se má inicializovat. Lze pøedat symbolické konstanty z následující tabulky nebo jejich binárnì OR-ovanou kombinaci.</p>

<table>
<tr align="left"><th>Symbolická konstanta</th>	<th>Inicializuje se...</th></tr>
<tr><td>SDL_INIT_VIDEO</td>				<td>grafika</td></tr>
<tr><td>SDL_INIT_AUDIO</td>				<td>zvuky</td></tr>
<tr><td>SDL_INIT_TIMER</td>				<td>èasovaèe</td></tr>
<tr><td>SDL_INIT_CDROM</td>				<td>CD-ROM</td></tr>
<tr><td>SDL_INIT_JOYSTICK</td>			<td>joystick</td></tr>
<tr><td>SDL_INIT_EVERYTHING</td>			<td>v¹e</td></tr>
<tr><td>SDL_INIT_NOPARACHUTE</td>			<td>nereagovat na chybové signály (SIGSEGV ap.)</td></tr>
</table>

<p>Linux a BeOS podporují také parametr SDL_INIT_EVENTTHREAD, který, pokud bude pøedán do SDL_Init(), zpùsobí, ¾e smyèka hlídající události bude bì¾et asynchronnì ve vlastním vláknu.</p>

<p>Pozn.: Pokud budete mít problémy s ladìním SDL aplikace ve Visual C++ debuggeru, zkuste nastavit flag SDL_INIT_NOPARACHUTE.</p>


<h2>Inicializace dal¹ích subsystémù</h2>

<p>Kdykoli po hlavní inicializaci lze pomocí následující funkce inicializovat i dal¹í subsystémy. Chování obou rutin je analogické.</p>

<pre>
int SDL_InitSubSystem(Uint32 flags);
</pre>


<h2>Kontrola inicializace subsystémù</h2>

<p>Zji¹tìní, které subsystémy byly inicializovány a které ne se provede pomocí</p>

<pre>
Uint32 SDL_WasInit(Uint32 flags);
</pre>

<p>Za parametr flags se pøedají subsystémy, které se mají otestovat a vrácena je bitová maska subsystémù, které jsou inicializované.</p>

<p>V následujícím pøíkladu se pokusí aplikace o inicializaci grafického a zvukového subsystému. Pokud se grafiku nepodaøí inicializovat, program skonèí. V pøípadì nedostupnosti zvukù bude program pokraèovat dále bez nich.</p>

<pre>
// Globální promìnná
bool use_audio = true;

// V main()
if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) == -1)
{
	fprintf(stderr, &quot;Unable to initialize SDL: %s\n&quot;,
			SDL_GetError());

	Uint32 flags = SDL_WasInit(SDL_INIT_VIDEO | SDL_INIT_AUDIO);

	// Grafika musí být v¾dy
	if(!(flags & SDL_INIT_VIDEO))
	{
		SDL_Quit();
		return 1;
	}

	// Zvuky pou¾ívat pouze, pokud jsou dostupné
	use_audio = (flags & SDL_INIT_AUDIO) ? true : false;
}
</pre>


<h2>Urèení typu chyby</h2>

<p>V pøíkladu vý¹e byla po neúspì¹né inicializaci vypisována chybová zpráva, na její¾ konec byl pøipojen øetìzec s upøesnìním získaným od SDL. Funkce SDL_GetError() vrátí NULLem ukonèený øetìzec, obsahující informace o poslední vnitøní chybì SDL.</p>

<pre>
char *SDL_GetError(void);
</pre>

<p>Dále existují je¹tì dvì funkce, které jsou v¹ak urèeny spí¹e pro vývojáøe knihovny SDL ne¾ pro její u¾ivatele. Pomocí první se nastavuje øetìzec s chybou a druhou se ma¾e.</p>

<pre>
void SDL_SetError(const char *fmt, ...);
void SDL_ClearError(void);
</pre>

<p>Pozn.: U vý¹e uvedeného výpisu textu pomocí fprintf() resp. printf() se v Linuxu zobrazí text do konzole, pod MS Windows v nekonzolové aplikaci se ve stejném adresáøi, kde je umístìn spu¹tìný EXE soubor, automaticky vytvoøí soubory stderr.txt a stdout.txt.</p>


<h2>Deinicializace</h2>

<p>Pøed ukonèením programu by mìla být v¾dy zavolána funkce SDL_Quit(), která se postará o ve¹kerý úklid.</p>

<pre>
void SDL_Quit(void);
</pre>

<p>V nìkterých cizích zdrojových kódech se lze té¾ setkat s pøíkazem atexit(SDL_Quit);, který je zapsán hned za SDL_Init() a který pøi ukonèení programu zavolá SDL_Quit() automaticky. Nicménì ka¾dá trochu del¹í aplikace obsahuje alespoò náznak nìjaké ukonèovací logiky, lep¹í je umístit SDL_Quit() tam.</p>

<p>Podobnì jako mìlo SDL_Init() protìj¹ek v SDL_InitSubSystem() i SDL_Quit() má svùj SDL_QuitSubSystem(). Pokud ale není subsystém ukonèován nìkde uprostøed aplikace, staèí na konci zavolat pouze SDL_Quit() a je uvolnìno v¹echno.</p>

<pre>
void SDL_QuitSubSystem(Uint32 flags);
</pre>


<h2>Ukázkový program</h2>

<p>Tento díl bude bohu¾el bez pøíkladu. Probíraná látka byla pøedbì¾nì ukázána u¾ v programu z minulé lekce.</p>


<h2>Download</h2>

<p><ul>
<li><a href="sdl_03.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Pøí¹tì se podíváme na vytváøení okna se v¹ím, co s tím souvisí.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 10.02.2005</div>

</body>
</html>
