<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (19)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (19)</h1>

<p class="perex">V¹e, co se týká SDL audio funkcí u¾ máme probráno, tak¾e se zkusíme podívat na roz¹iøující knihovnu SDL_mixer.</p>


<h2>SDL_mixer</h2>

<p>Knihovna <a href="http://www.libsdl.org/projects/SDL_mixer/">SDL_mixer</a> poskytuje snadno pou¾itelné funkce pro mixování zvukù a hudby. Je vhodná obzvlá¹» pro ty, kterým pøipadá standardní SDL audio API pøíli¹ nízkoúrovòové a strohé. Aby bylo se SDL_mixerem v¹e co nejjednodu¹¹í, pøímo v knihovnì lze nalézt podporu i pro nahrávání zvukù z formátù jako jsou .WAV, .AIFF, .VOC, .OGG, .MP3 a dal¹í, u nìkterých ale jen s pou¾itím externích dekodérù.</p>

<p>SDL_mixer je, stejnì jako SDL, ¹íøen pod licencí GNU LGPL. Ve¹keré rozhraní je deklarováno v hlavièkovém souboru SDL_mixer.h a pøi linkování programu je nutné pøidat do pøíkazové øádky øetìzec -lSDL_mixer. V¹echny funkce z této knihovny zaèínají na pøedponu 'Mix_'.</p>

<p>Pøi zakládání aplikace byste si mìli v¾dy rozmyslet, zda budete pro zvuky a hudbu pou¾ívat SDL_mixer, nebo SDL audio funkce. Kombinace obou technik je sice mo¾ná, ale nemusí být zrovna ¹»astným nápadem. U SDL_mixeru byste se mìli rozhodnì vyvarovat volání funkcí jako SDL_OpenAudio(), SDL_CloseAudio(), SDL_PauseAudio(), SDL_LockAudio(), SDL_UnlockAudio() apod., mohou být konfliktní s jejich Mix_*() analogiemi.</p>


<h2>Obecné funkce</h2>

<p>Inicializace knihovny a souèasnì i otevøení audio zaøízení se v SDL_mixeru provádí funkcí Mix_OpenAudio().</p>

<pre>
int Mix_OpenAudio(int frequency, Uint16 format,
		int channels, int chunksize);
</pre>

<p>Parametry by mìly být jasné. Místo konkrétní frekvence mù¾e být pou¾ita symbolická konstanta MIX_DEFAULT_FREQUENCY, která má hodnotu 22050 Hz. Za druhý parametr, formát vzorkù, je mo¾né pøedat libovolnou z konstant definovaných v SDL, popø. MIX_DEFAULT_FORMAT má hodnotu AUDIO_S16SYS. U tøetího parametru oznaèuje jednièka mono a dvojka stereo, chunksize definuje velikost ka¾dého mixovaného bloku.</p>

<p>Funkce oznamuje chybu vrácením -1, je-li v¹e v poøádku, vrátí nulu.</p>

<p>Zavøení zaøízení a deinicializace knihovny jsou uskuteèòovány funkcí Mix_CloseAudio(). Mix_GetError() slou¾í pro získání øetìzce obsahujícího popis poslední chyby a pomocí Mix_SetError() ji lze definovat.</p>

<pre>
void Mix_CloseAudio();

char *Mix_GetError();
void Mix_SetError(const char *fmt, ...);
</pre>

<p>V následujícím pøíkladu je otevøeno audio zaøízení s pøeddefinovanou frekvencí a formátem, bude se jednat o stereo, a velikost blokù dat bude 1024 bytù.</p>

<pre>
// Inicializace
if(Mix_OpenAudio(MIX_DEFAULT_FREQUENCY,
		MIX_DEFAULT_FORMAT, 2, 1024) == -1)
{
	printf("Mix_OpenAudio(): %s\n", Mix_GetError());
	return false;
}

// Deinicializace
Mix_CloseAudio();
</pre>

<p>Parametry aktuálnì otevøeného audio zaøízení lze získat voláním funkce Mix_QuerySpec(), která pøi chybì vrací nulu.</p>

<pre>
int Mix_QuerySpec(int *frequency, Uint16 *format, int *channels);
</pre>


<h2>Zvuky</h2>

<p>Zvuky jsou v SDL_mixeru reprezentovány strukturou Mix_Chunk, její¾ popis není pro programování dùle¾itý. Mìlo by staèit pøedávat do funkcí ukazatele na její objekty.</p>

<p>Pro základní nahrávání zvukù ze souboru slou¾í funkce Mix_LoadWAV(). Pøedává se jí jméno souboru na disku a v pøípadì úspìchu je vrácen ukazatel na zvuk, chyba je oznámena klasicky pomocí NULL. Druhá funkce, Mix_LoadWAV_RW(), se pou¾ívá pro nahrávání ze SDL_RWops. Nenulová hodnota ve druhém parametru zpùsobí automatické zavøení a uvolnìní zdroje, kdy¾ u¾ není potøeba.</p>

<pre>
Mix_Chunk *Mix_LoadWAV(char *file);
Mix_Chunk *Mix_LoadWAV_RW(SDL_RWops *src, int freesrc);
</pre>

<p>Dal¹í mo¾ností, jak nahrávat zvuky do aplikace jsou dvì funkce Mix_QuickLoad_*(), které umo¾òují pracovat s daty v pamìti. U¾ v dobì volání funkce musejí být zvuky ve výstupním formátu a v podstatì vìt¹inu chyb není testována, pou¾ití mù¾e být tudí¾ relativnì nebezpeèné. V¾dy byste mìli vìdìt, co dìláte.</p>

<pre>
Mix_Chunk *Mix_QuickLoad_WAV(Uint8 *mem);
Mix_Chunk *Mix_QuickLoad_RAW(Uint8 *mem);
</pre>

<p>Po skonèení práce s daným zvukem by se mìl v¾dy pomocí Mix_FreeChunk() uvolnit.</p>

<pre>
void Mix_FreeChunk(Mix_Chunk *chunk);
</pre>

<p>Hlasitost zvuku se dá softwarovì nastavit voláním Mix_VolumeChunk(), které se pøedává po¾adovaná hlasitost v rozsahu od nuly do MIX_MAX_VOLUME (=128). Návratovou hodnotou je pøedchozí hlasitost.</p>

<pre>
int Mix_VolumeChunk(Mix_Chunk *chunk, int volume);
</pre>

<p>Jak poznáme dále, je tato funkce pouze jednou z mo¾ností, jak nastavit výslednou hlasitost zvukového výstupu.</p>


<h2>Kanály a pøehrávání</h2>

<p>SDL_mixer defaultnì alokuje celkem osm kanálù, v ka¾dém z nich mù¾e být v jednom okam¾iku pøehráván právì jeden zvuk. Pokud je spu¹tìn zvuk v kanálu, ve kterém se u¾ nìco pøehrává, pùvodní se zastaví a je spu¹tìn nový. Poèet kanálù se dá upravit funkcí Mix_AllocateChannels().</p>

<pre>
int Mix_AllocateChannels(int numchans);
</pre>

<p>Pokud bude po¾adovaný poèet kanálù men¹í ne¾ pùvodní, budou nejvy¹¹í zavøeny a uvolnìny. Návratovou hodnotou je poèet novì alokovaných kanálù.</p>

<p>Podobnì, jako ¹lo nastavit hlasitost zvuku, lze navíc nastavit i hlasitost kanálu. Za první parametr se pøedává poøadové èíslo kanálu, v pøípadì zadání -1 se operace provede nad v¹emi (platí obecnì). Druhým parametrem se definuje po¾adovaná hlasitost.</p>

<pre>
int Mix_Volume(int channel, int volume);
</pre>

<p>Návratovou hodnotou je aktuální hlasitost kanálu, popø. prùmìr, pokud byly zvoleny v¹echny.</p>

<p>Pøíkaz na pøehrávání zvuku poskytuje funkce Mix_PlayChannel(). Prvním parametrem se opìt volí kanál, -1 zde má význam prvního volného kanálu. Druhý parametr specifikuje pøehrávaný zvuk a tøetí poèet opakování + 1 (nula jedenkrát, jedna dvakrát atd.). Speciální hodnotou je -1, oznaèuje nekoneènou smyèku.</p>

<pre>
int Mix_PlayChannel(int channel, Mix_Chunk *chunk, int loops);

int Mix_PlayChannelTimed(int channel, Mix_Chunk *chunk,
		int loops, int ticks);
</pre>

<p>U druhé uvedené funkce je mo¾né v posledním parametru zadat navíc èasový limit v milisekundách. Pokud po uplynutí této doby zvuk stále hraje, bude automaticky ukonèen.</p>

<p>Obì funkce vracejí èíslo kanálu, ve kterém bude zvuk pøehráván nebo -1 na znamení chyby. Vìt¹inou se jedná o to, ¾e ¾ádný kanál nebyl volný, ale mù¾e se také jednat o kritickou chybu.</p>

<p>Dal¹í mo¾ností, jak spustit pøehrávání zvuku je funkce Mix_FadeInChannel(). Za poslední parametr se pøedává èasový interval v milisekundách, bìhem kterého zvuk postupnì nabývá na síle.</p>

<pre>
int Mix_FadeInChannel(int channel, Mix_Chunk *chunk,
		int loops, int ms);
int Mix_FadeInChannelTimed(int channel, Mix_Chunk *chunk,
		int loops, int ms, int ticks);
</pre>

<p>Zvuk pøehrávaný v kanálu se dá pozastavit voláním funkce Mix_Pause() a následnì obnovit pomocí Mix_Resume(). Pro kompletní stopnutí slou¾í jedna ze tøí následujících funkcí. Mix_HaltChannel() zastaví pøehrávání ihned, Mix_ExpireChannel() a¾ po uplynutí èasového intervalu a Mix_FadeOutChannel() zpùsobí pro postupné odeznívání.</p>

<pre>
void Mix_Pause(int channel);
void Mix_Resume(int channel);

int Mix_HaltChannel(int channel);
int Mix_ExpireChannel(int channel, int ticks);
int Mix_FadeOutChannel(int channel, int ms);
</pre>

<p>Mo¾ná je to zbyteèné pøipomínat, ale zvlá¹tì u tìchto funkcí se lze velice èasto setkat s parametrem -1, který operuje nad v¹emi kanály.</p>

<p>Pomocí Mix_ChannelFinished() lze pøedat SDL_mixeru ukazatel na funkci, která se pak automaticky spustí, kdykoli se pøehrávání v jakémkoli kanálu ukonèí. Nikdy by se v ní nemìly volat ¾ádné audio funkce!</p>

<pre>
void Mix_ChannelFinished(void (*channel_finished)(int channel));
</pre>

<p>V následujícím pøíkladu se po ukonèení pøehrávání vypí¹e informaèní zpráva.</p>

<pre>
// Callback funkce
void ChannelFinishedCallback(int channel)
{
	printf("Kanál %d ukonèil pøehrávání.\n", channel);
}

// Pøedání ukazatele na funkci
Mix_ChannelFinished(ChannelFinishedCallback);
</pre>

<p>Následující skupina funkcí slou¾í pro dotazy na stav pøehrávání, nemìlo by být tøeba je zdlouhavì popisovat. Pokud je za kanál pøedáno èíslo -1, vrací první dvì funkce poèet kanálù, které vyhovìly dotazùm. Poslední uvedená funkce vrátí pøi dotazu jednu z konstant MIX_FADING_IN, MIX_FADING_OUT nebo MIX_NO_FADING. Parametr -1 zde není validní.</p>

<pre>
int Mix_Playing(int channel);
int Mix_Paused(int channel);
Mix_Fading Mix_FadingChannel(int which);
</pre>

<p>Poslední funkce tohoto èlánku, Mix_GetChunk(), vrací ukazatel na zvuk, který je pøehráván v definovaném kanálu, popø. byl pøehráván jako poslední. Jeliko¾ u¾ mù¾e být zvuk uvolnìn, nemusí být ukazatel v dané chvíli validní!</p>

<pre>
Mix_Chunk *Mix_GetChunk(int channel);
</pre>


<h2>Ukázkové programy</h2>

<h3>SDL_mixer</h3>

<p>Aplikace inicializuje SDL_mixer, otevøe audio zaøízení a nahraje zvuk. Zaèátek pøehrávání je umo¾nìn stiskem mezerníku a konec pomocí enteru. V obou pøípadech je ponechána doba tøí sekund na postupné nabírání na síle resp. odeznìní. <a href="./src/sdl_19_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>


<h2>Download</h2>

<p><ul>
<li><a href="http://www.libsdl.org/projects/SDL_mixer/">Domovská stránka knihovny SDL_mixer</a></li>
<li><a href="./src/sdl_19_a.tar.gz">Pøíklad: SDL_mixer</a></li>
<li><a href="sdl_19.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Ze SDL_mixeru máme probránu cca. polovinu, tak¾e se budeme pøí¹tì vìnovat té druhé. Bude pøedev¹ím o hudbì a efektech.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 28.06.2005</div>

</body>
</html>
