<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (18)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (18)</h1>

<p class="perex">V tomto díle konverzemi zvukù dokonèíme popis funkcí, které SDL poskytuje pro audio. Druhá èást èlánku bude vìnována roz¹iøující knihovnì SDL_sound, která slou¾í pro dekódování zvukù z .MP3, .MID, .OGG a dal¹ích bì¾nì roz¹íøených typù souborù.</p>


<h2>Konverze zvukù</h2>

<p>Transformace zvukù z jednoho formátu na jiný je v SDL dvoustupòový proces. Nejprve je nutné vytvoøit objekt struktury SDL_AudioCVT, nastavit ho na správné parametry a nakonec ho pøedat jako parametr do konverzní funkce.</p>

<pre>
typedef struct
{
	int needed;
	Uint16 src_format;
	Uint16 dest_format;
	double rate_incr;
	Uint8 *buf;		// Buffer s daty
	int len;		// Délka originálu
	int len_cvt;
	int len_mult;		// Výpoèet délky pro alokaci
	double len_ratio;	// Výpoèet výsledné délky
	void (*filters[10])(struct SDL_AudioCVT *cvt, Uint16 format);
	int filter_index;
} SDL_AudioCVT;
</pre>

<p>Vìt¹ina atributù struktury mù¾e být pova¾ována za privátní, budeme se proto zabývat jen tìmi, které jsou dùle¾ité pro pou¾ívání.</p>

<p>Buf je ukazatelem na zvuk a to jak zdrojový, tak cílový. Pùvodní data tedy budou konverzí pøepsána novými. Druhým dùsledkem je, ¾e se data mohou pøi konverzi zvìt¹it, a tudí¾ je nutné alokovat dostatek pamìti. Èíselnì by mìla být velká len*len_mult bytù, kde len pøedstavuje velikost pùvodních dat a len_mult obsahuje násobitel kolikrát se mohou maximálnì zvìt¹it, typickým pøíkladem je konverze 8-bitového zvuku na 16-bitový.</p>

<p>Len_ratio má podobný význam jako len_mult. Výsledkem násobení len*len_ratio bude po úspì¹né konverzi opravdová délka nových dat v bytech.</p>

<p>Pøedtím ne¾ mù¾e být objekt SDL_AudioCVT pou¾it pro konverzi, musí být inicializován informacemi o zdrojovém a cílovém formátu. K tomu slou¾í funkce SDL_BuildAudioCVT(), její¾ parametry jsou stejné jako u struktury SDL_AudioSpec probrané v minulém díle. Informace o zdrojovém zvuku jsou dostupné z naèítání a u cíle se v naprosté vìt¹inì pøípadù volí formát hardwaru ze SDL_OpenAudio().</p>

<pre>
int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
		Uint16 src_format, Uint8 src_channels, int src_rate,
		Uint16 dst_format, Uint8 dst_channels, int dst_rate);
</pre>

<p>Funkce v pøípadì úspìchu vrátí 1 a v pøípadì neúspìchu -1. Byla-li úspì¹ná, mù¾e se do parametru len konverzní struktury pøiøadit délka originálních dat, alokovat pamì» pro buffer o velikosti len*len_mult bytù a zkopírovat do nìj data zvuku. Pro samotnou konverzi se pak zavolá funkce SDL_ConvertAudio(), jejím¾ jediným parametrem je konverzní struktura. Úspìch oznaèuje vrácená 0 a neúspìch -1.</p>

<pre>
int SDL_ConvertAudio(SDL_AudioCVT *cvt);
</pre>

<p>Pokud v¹e probìhne bez problémù, budou výsledná data ulo¾ena v atributu buf struktury a jejich délka bude len*len_ratio bytù.</p>

<p>V prvním ukázkovém programu naleznete obecnì pou¾itelnou funkci LoadSound(), která nahraje zvuk ze souboru filename, zkonvertuje ho pomocí právì popsané techniky na libovolný formát a výsledek ulo¾í na adresu svého posledního parametru. Kód není vlo¾en pøímo do èlánku kvùli relativnì velké délce.</p>


<h2>Knihovna SDL_sound</h2>

<p>SDL_sound je knihovna urèená pro nahrávání zvukù mnoha populárních formátù a jejich dekódování. Aktuálnì podporovanými podle dokumentace jsou</p>

<ul>
<li>.WAV (Microsoft WAVfile RIFF data, internì)
<li>.VOC (Creative Labs' Voice formát, internì)
<li>.MP3 (MPEG-1 Layer 3, prostøednictvím SMPEG a mpglib)
<li>.MID (MIDI hudba konvertovaná na Waveform data, internì)
<li>.MOD (MOD formát, prostøednictvím MikMod a ModPlug)
<li>.OGG (Ogg formát, prostøednictvím Ogg Vorbis knihoven)
<li>.SPX (Speex formát, prostøednictvím libspeex)
<li>.SHN (Shorten formát, internì)
<li>.RAW (Raw zvuková data v jakémkoli formátu, internì)
<li>.AU  (Sun's Audio formát, internì)
<li>.AIFF (Audio Interchange formát, internì)
<li>.FLAC (Lossless audio komprese, prostøednictvím libFLAC)
</ul>

<p>Knihovna je ¹íøena pod licencí GNU LGPL, nicménì externí dekodéry mohou mít licenci jinou. Asi nejlep¹í bude, kdy¾ si pøeètete soubor COPYING z koøenového adresáøe archivu knihovny a následnì jednotlivé licence v¹ech v aplikaci pou¾ívaných formátù.</p>

<p>Pøi pou¾ití je nutné pøidat k parametrùm linkeru øetìzec -lSDL_sound, který zpùsobí pøilinkování knihovny k programu. Hlavièky v¹ech funkcí jsou umístìny v souboru SDL_sound.h a jejich jména zaèínají na jednotnou pøedponu 'Sound_'. Pokud nebude v textu uvedeno jinak, bude daná funkce vracet pøi chybì nulu, jinak nenulovou hodnotu.</p>

<p>Následující funkce jsou podobné svým SDL analogiím. Mìlo by staèit uvést, ¾e Sound_Init() by mìlo být voláno jako první ze v¹ech Sound_*() funkcí. Naproti tomu Sound_Quit() uvolní v¹echny systémové prostøedky alokované knihovnou SDL_sound a mìlo by být umístìno v kódu v¾dy pøed SDL_Quit().</p>

<pre>
int Sound_Init(void);			// Inicializace
int Sound_Quit(void);			// Deinicializace
const char *Sound_GetError(void);	// Vrátí chybový øetìzec
void Sound_ClearError(void);		// Vynuluje ho
</pre>

<p>Zji¹tìní, které dekodéry jsou aktuálnì dostupné, lze provést funkcí Sound_AvailableDecoders(), která vrací ukazatel na pole struktur s informacemi o dekodérech. Poslední polo¾ka je zará¾kou a má hodnotu NULL.</p>

<pre>
const Sound_DecoderInfo **Sound_AvailableDecoders(void);

typedef struct
{
	const char **extensions;	// Pøípona souboru
	const char *description;	// Popis dekodéru
	const char *author;		// Autor
	const char *url;		// URL dekodéru
} Sound_DecoderInfo;
</pre>


<h2>Loading zvukù</h2>

<p>Zvukový soubor v libovolném podporovaném formátu se do aplikace dá nahrát jednou ze dvou ní¾e uvedených funkcí. První z nich slou¾í pro nahrávání ze SDL_RWops (SDL abstrakce nad vstupními daty), parametr ext je pouze nápovìdou pøi hledání vhodného dekodéru. Druhá funkce slou¾í pro naèítání z diskového souboru.</p>

<pre>
Sound_Sample *Sound_NewSample(SDL_RWops *rw,
		const char *ext,
		Sound_AudioInfo *desired,
		Uint32 bufferSize);

Sound_Sample *Sound_NewSampleFromFile(const char *fname,
		Sound_AudioInfo *desired,
		Uint32 bufferSize);
</pre>

<p>Parametrem desired lze urèit do jakého formátu má být zvuk pøi dekódování zkonvertován. V pøípadì, ¾e nejsou konverze potøeba, mù¾e být nastaven na NULL. V¹echny tøi atributy mají ve struktuøe SDL_AudioSpec své analogie, tak¾e k inicializace staèí pouze tøi jednoduchá pøiøazení.</p>

<pre>
typedef struct
{
	Uint16 format;	// Formát zvuku
	Uint8 channels;	// 1 - mono, 2 - stereo
	Uint32 rate;	// Frekvence (vzorky za sekundu)
} Sound_AudioInfo;
</pre>

<p>Poslední parametr, bufferSize, urèuje poèáteèní velikost ètecího bufferu v bytech. Èím je vìt¹í, tím více dekódování mù¾e být provedeno v jednom bloku, na druhou stranu bude trvat o nìco déle a bude zabráno více zdrojù. Pro rùzné formáty mohou být vhodné jiné hodnoty, ka¾dopádnì velikost musí být v¾dy násobkem velikosti vzorku. Pokud pou¾íváte napøíklad 16-bitové stereo, kde zabírá ka¾dý vzorek 2*2 bytù, musí být velikost násobkem 4.</p>

<p>Obì funkce vrací ukazatel na objekt struktury Sound_Sample, která je pro SDL_sound dùle¾itá asi stejnì, jako SDL_Surface pro SDL. Tento objekt ukládá v¹echny informace o zvukových datech a stavu jejich dekódování. Atributy by mìly být pova¾ovány za READ-ONLY, pro jejich zmìny se vyu¾ívají výhradnì API funkce.</p>

<pre>
typedef struct
{
	void *opaque;			// Interní pou¾ití
	const Sound_DecoderInfo *decoder;// Pou¾ívaný dekodér
	Sound_AudioInfo desired;	// Formát pro konverze
	Sound_AudioInfo actual;		// Aktuální formát vzorku
	void *buffer;			// Buffer dekódovaných dat
	Uint32 buffer_size;		// Velikost bufferu v bytech
	Sound_SampleFlags flags;	// Flagy vzorku
} Sound_Sample;
</pre>

<p>Po skonèení práce by se mìly v¹echny pou¾ívané zdroje uvolnit. Slou¾í k tomu funkce Sound_FreeSample(), staèí jí pøedat ukazatel na nahraný zvuk.</p>

<pre>
void Sound_FreeSample(Sound_Sample *sample);
</pre>


<h2>Dekódování dat</h2>

<p>Voláním funkce Sound_Decode() se dekódují ze vzorku v poøadí následující data. Jejich velikost bude vìt¹inou sample-&gt;buffer_size bytù a budou ulo¾ena do sample-&gt;buffer. Návratová hodnota dává informaci kolik bytù bylo skuteènì nahráno.</p>

<pre>
Uint32 Sound_Decode(Sound_Sample *sample);
</pre>

<p>Pokud nelze nahrát v¹ech sample-&gt;buffer_size bytù, informace o dùvodu se dají najít v sample-&gt;flags. Vìt¹inou se jedná o konec streamu (SOUND_SAMPLEFLAG_EOF) nebo o nìjakou chybu (SOUND_SAMPLEFLAG_ERROR).</p>

<pre>
if(sample->flags & SOUND_SAMPLEFLAG_ERROR)
	NecoUdelej();
</pre>

<p>Pro dekódování v¹ech zvukových dat slou¾í funkce Sound_DecodeAll(), která do sample-&gt;buffer dynamicky alokuje potøebnou pamì» a ulo¾í do ní výsledná data, sample-&gt;buffer_size bude obsahovat jejich velikost. Opìt by se mìly testovat flagy ze sample-&gt;flags.</p>

<pre>
Uint32 Sound_DecodeAll(Sound_Sample *sample);
</pre>

<p>Pøi dekódování celého zvuku najednou si radìji dávejte pozor na velikost alokované pamìti, sami jistì pøijdete na to, jak by to dopadlo u pùlhodinové mp3.</p>

<p>Zmìna velikosti ètecího bufferu se dá uskuteènit funkcí Sound_SetBufferSize(). Pro hodnotu nové velikosti platí stejné zásady, jako u Sound_NewSample().</p>

<pre>
int Sound_SetBufferSize(Sound_Sample *sample, Uint32 new_size);
</pre>

<p>V pøípadì, ¾e se nedá velikost zmìnit, bude se pracovat i nadále s pùvodní. Pøi zkrácení budou data na konci zahozena a pøi prodlou¾ení bude konec bufferu nedefinovaný do té doby, ne¾ se nahrají nová data.</p>


<h2>Skoky na nové pozice</h2>

<p>Základním skokem je pøesun na zaèátek zvuku, který se vykoná funkcí Sound_Rewind(). Teoreticky by k chybì nemìlo nikdy dojít.</p>

<pre>
int Sound_Rewind(Sound_Sample *sample);
</pre>

<p>Druhá funkce, Sound_Seek(), umo¾òuje pøesun na libovolné místo definované èasem v milisekundách od zaèátku.</p>

<pre>
int Sound_Seek(Sound_Sample *sample, Uint32 ms);
</pre>

<p>Nìkteré dekodéry nemusejí pøeskoky vùbec podporovat a nìkteré pouze s urèitými soubory, proto byste mìli pøed dotazem otestovat flagy na SOUND_SAMPLEFLAG_CANSEEK. Pokud pøesun sel¾e, mìl by se zvuk chovat, jako by volání nikdy nebylo provedeno. Pøi neo¹etøitelné chybì jsou flagy nastaveny na SOUND_SAMPLEFLAG_ERROR.</p>


<h2>Ukázkové programy</h2>

<h3>Konverze zvukù</h3>

<p>Program demonstruje pøehrávání více zvukù najednou. Jeden bude hudbou ve smyèce na pozadí a druhý bude spou¹tìn v¾dy po stisku mezerníku. Pøi nahrávání funkcí LoadSound() se zvuky zkonvertují na stejný (hardwarový) formát. <a href="./src/sdl_18_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>


<h3>SDL_sound</h3>

<p>Program ukazuje nahrávání zvuku ve formátu .AU pomocí knihovny SDL_sound, jeho dekódování a následné pøehrávání (opìt pro jednoduchost smyèka). Je zde pou¾it .AU, ale naprosto stejným zpùsobem lze nahrávat zvukové soubory jakýchkoli jiných podporovaných formátù (.MP3, .OGG, atd.), staèí jen zmìnit jméno souboru. <a href="./src/sdl_18_b.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>


<h2>Download</h2>

<p><ul>
<li><a href="http://icculus.org/SDL_sound/">Domovská stránka knihovny SDL_sound</a></li>
<li><a href="./src/sdl_18_a.tar.gz">Pøíklad: Konverze zvukù</a></li>
<li><a href="./src/sdl_18_b.tar.gz">Pøíklad: SDL_sound</a></li>
<li><a href="sdl_18.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Dnes u¾ na pùvodnì slibovanou knihovnu SDL_mixer nezbylo místo, tak¾e pøí¹tì...</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 19.06.2005</div>

</body>
</html>
