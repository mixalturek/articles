<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (22)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (22)</h1>

<p class="perex">V dne¹ním díle o knihovnì SDL se budeme vìnovat podpoøe tzv. vícevláknového programování. Podíváme se na vytváøení nových vláken a samozøejmì také jejich synchronizaci, která nikdy nesmí chybìt.</p>


<h2>Jednovláknové a vícevláknové programy</h2>

<p>Mít v programu více vláken mù¾e být velice výhodné. Jedno se stará o události, druhé o vykreslování a animace, tøetí s pátým o cokoli jiného a v¹echno se to vykonává souèasnì. Na stranu druhou si lze multithreadingem zadìlat na tak obrovskou hromadu problémù, jaké si programátor &quot;klasických&quot; aplikací nedoká¾e ani pøedstavit.</p>

<p>Typickým pøíkladem jednovláknového programu je Hello, World. Na zaèátku se spustí main(), v ní se nìco vypí¹e a pak se ukonèí. V libovolném okam¾iku bìhu programu je mo¾né zjistit, jaká instrukce právì probìhla a jaká bude následovat.</p>


<h2>Spou¹tìní vláken</h2>

<p>Vícevláknový program také zaèíná funkcí main(), ale v urèitém okam¾iku se rozhodne, ¾e by bylo vhodné spustit dal¹í vlákno. V pøípadì SDL je tím okam¾ikem volání SDL_CreateThread(), které se pøedává ukazatel na libovolnou funkci, její¾ kód se bude v novì vytvoøeném vláknu provádìt. Vlákno se ukonèí spolu s návratem z této funkce.</p>

<pre>
SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
</pre>

<p>Parametr typu void* je zde zvolen naprosto zámìrnì. Díky nìmu lze pøedat pøes ukazatel data do funkce v podstatì cokoliv. Aby ¹lo pracovat s vlákny, je nutné inkludovat hlavièkový soubor SDL_thread.h, v nìm¾ se deklaruje v¹e potøebné.</p>

<p>Po prùchodu funkcí SDL_CreateThread() se bude staré i nové vlákno vykonávat témìø souèasnì. Slovo 'témìø' v tomto pøípadì znamená, ¾e na poèítaèi s více procesory pùjde (teoreticky) o paralelní bìh. V pøípadì jednoprocesorového systému se vlákna dynamicky pøepínají, perioda je v jednotkách a¾ desítkách milisekund, tak¾e pro u¾ivatele v podstatì neexistuje.</p>

<p>Pozn.: Teorie vícevláknového programování vìt¹inou pracuje také s tzv. procesy. Rozdíl mezi procesem a vláknem je ten, ¾e jednotlivá vlákna sdílejí v¹echny systémové prostøedky (pamì» apod.), kde¾to procesy jsou kompletnì oddìlené. Ka¾dý program ulo¾ený na disku se po svém spu¹tìní stává procesem, mù¾e spou¹tìn dal¹í procesy a v nich vlákna. SDL vytváøení procesù neumo¾òuje.</p>

<p>Hlavní vlákno by nikdy nemìlo skonèit døíve ne¾ v¹echna jím vytvoøená vlákna. SDL pro tento úèel poskytuje dvì funkce SDL_WaitThread() a SDL_KillThread(). První z nich èeká neomezenou dobu na ukonèení a zároveò pøebírá návratovou hodnotu, druhá funkce vlákno natvrdo zastaví.</p>

<p>Je-li to alespoò trochu mo¾né, mìlo by se v¾dy poèkat na návrat z funkce spu¹tìné ve vláknu. Pokud napøíklad alokovalo dynamickou pamì», nemìlo by ji ¹anci uvolnit.</p>

<pre>
void SDL_WaitThread(SDL_Thread *thread, int *status);
void SDL_KillThread(SDL_Thread *thread);
</pre>

<p>ID vlákna lze získat pomocí SDL_ThreadID() a SDL_GetThreadID(). První z funkcí uva¾uje aktuální spu¹tìné vlákno a druhá libovolné pøedané.</p>

<pre>
Uint32 SDL_ThreadID(void);
Uint32 SDL_GetThreadID(SDL_Thread *thread);
</pre>

<p>V následujícím výpisu vytvoøí funkce main() pracovní vlákno reprezentované funkcí vlakno(), obì se pak budou vykonávat paralelnì. S na¹imi dosavadními znalostmi je v¹e naprogramováno správnì, ale jak si uká¾eme za chvíli, do kódu bude nutné je¹tì nìco dopsat.</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;SDL.h&gt;
#include &lt;SDL_thread.h&gt;

int vlakno(void *arg)
{
	// Nìjaký kód
	for(int i = 0; i &lt; 10000; i++)
		printf("vlakno()\n");

	return 0;
}

int main(int argc, char *argv[])
{
	// Inicializace SDL

	SDL_Thread *thread;
	if((thread = SDL_CreateThread(vlakno, NULL)) == NULL)
	{
		fprintf(stderr, "Nelze vytvoøit vlákno: %s",
				SDL_GetError());
		return 1;
	}

	// Nìjaký kód
	for(int i = 0; i &lt; 10000; i++)
		printf("main()\n");

	// Poèká se na ukonèení vlákna
	SDL_WaitThread(thread, NULL);
	return 0;
}
</pre>

<p>Výstup z programu jsem malièko upravil, ve skuteènosti stihne vlákno, pøed pøepnutím do dal¹ího, zobrazit údajù mnohem více.</p>

<pre>
vlakno()
main()
main()
main()
vlakno()
vlakno()
main()
vlakno()
</pre>


<h2>Synchronizace vláken</h2>

<p>Do této chvíle bylo v¹e docela jednoduché, hlavním problémem u vláken je pøedev¹ím jejich synchronizace a související integrita sdílených dat. Vrátíme-li se k pøedchozí ukázce, výstup programu bude ve skuteènosti vypadat spí¹e následovnì.</p>

<pre>
main()
mvlakno()
vlakno()
vlakain()
mainno()
vlakno()
</pre>

<p>Nikde není øeèeno, ¾e se vlákna nemohou pøepnout bìhem vykonávání funkce printf(), tak¾e se oba výpisy (ne)oèekávanì slijí dohromady. Ve výsledku je text naprosto neèitelný. Vytvoøení dal¹ích vláken není nic slo¾itého, tì¾ká je spí¹e jejich synchronizace, aby nedocházelo k podobným stavùm, jako v pøíkladu.</p>

<p>Jenom tak na okraj: neèekejte, ¾e po pøeètení tohoto èlánku se stanete expertem na paralelní systémy, k rozebrání tohoto tématu na alespoò trochu obstojné úrovni by mo¾ná nestaèila ani nìkolikasetstránková publikace. Jestli Vás mohu poprosit, berte tento èlánek spí¹e jako &quot;populárnì vìdecké&quot; seznámení...</p>

<p>V podstatì v¹echny nástroje pro synchronizaci jsou, velice zjednodu¹enì øeèeno, jakési flagy øídící pøístup do úsekù programu, ve kterých mù¾e dojít k vzájemnému ovlivnìní vláken. U¾ jsme se setkali se slitím výpisù v ukázkovém programu, typicky se jedná o pøístup ke sdíleným (globálním) promìnným. Pamatujete-li si je¹tì na dvojici funkcí lock/unlock z grafiky popø. zvukù, musely se volat právì kvùli multithreadingu.</p>

<p>Pozn.: Výraz 'kritická sekce' není v textu pou¾íván zámìrnì. Ve Win32 API se jedná pøímo o synchronizaèní prostøedek, mohlo by se to plést.</p>


<h3>Mutexy</h3>

<p>Jeden z prostøedkù pro synchronizaci vláken pøedstavují tzv. mutexy, které jsou v SDL dostupné prostøednictvím struktury SDL_mutex. Ukazatel na novì vytvoøený, odemknutý mutex je mo¾né získat funkcí SDL_CreateMutex(), po skonèení práce by se mìl v¾dy pomocí SDL_DestroyMutex() uvolnit.</p>

<pre>
SDL_mutex *SDL_CreateMutex(void);
void SDL_DestroyMutex(SDL_mutex *mutex);
</pre>

<p>Pro zamknutí mutexu slou¾í funkce SDL_mutexP(), respektive její alias SDL_LockMutex(). Je-li u¾ mutex zamknut jiným vláknem, vykonávání této funkce probíhá do té doby, ne¾ je mutex odemknut. Zamykání je navíc násobné, tak¾e poèet zamknutí musí odpovídat poètu odemknutí. V pøípadì úspìchu vrátí funkce 0 a neúspìchu -1 (platí obecnì u v¹ech funkcí, dále u¾ to nebude zmiòováno).</p>

<pre>
// Zamknutí
#define SDL_LockMutex(m) SDL_mutexP(m)
int SDL_mutexP(SDL_mutex *mutex);

// Odemknutí
#define SDL_UnlockMutex(m) SDL_mutexV(m)
int SDL_mutexV(SDL_mutex *mutex);
</pre>

<p>Uvedeme si jeden velice dùle¾itý poznatek, který nemusí být na první pohled vidìt. Pokud pou¾íváte dva rùzné mutexy (platí i pro ostatní synchronizaèní prostøedky), mìli byste si dávat pozor na poøadí jejich zamykání. Symbolicky naznaèené poøadí</p>

<pre>
// VLÁKNO 1
lock(A);
lock(B);
// Pøístup ke sdíleným prostøedkùm
unlock(B);
unlock(A);

// VLÁKNO 2
lock(B);
lock(A);
// Pøístup ke sdíleným prostøedkùm
unlock(A);
unlock(B);
</pre>

<p>mù¾e zpùsobit tzv. deadlock projevující se kompletním zamrznutím programu. Po nakreslení pøíkazù jednotlivých vláken vedle sebe, by mìlo být v¹e jasné.</p>

<pre>
VLÁKNO 1		VLÁKNO 2

...			...
lock(A);		...
...			...
...			lock(B);
lock(B);		...
...			lock(A);
...			...
wait(B);		wait(A);
wait(B);		wait(A);
</pre>

<p>Pozn.: Mutexy si lze zjednodu¹enì pøedstavit jako bool hodnotu s urèitým, pevnì stanoveným rozhraním. Obyèejné promìnné v¹ak pro synchronizaci vláken nelze pou¾ívat, proto¾e kompilátor nemusí pøelo¾it ani obyèejné pøiøazení jedinou (atomickou) instrukcí procesoru. Naproti tomu, rozhraní synchronizaèních prostøedkù zaruèuje, ¾e bìhem testu a následného zamknutí nemù¾e dojít k pøepnutí vláken.</p>

<p>Následuje pøíklad na aplikaci mutexù vèetnì jejich vytváøení a ru¹ení.</p>

<pre>
// Globální promìnné
SDL_mutex *g_mutex;
int g_promenna;

// Vytvoøení mutexu (inicializace)
g_mutex = SDL_CreateMutex();

// Zamknutí mutexu
if(SDL_mutexP(g_mutex) == -1)
{
	fprintf(stderr, "Nelze zamknout mutex\n");
	// Vhodná reakce
}

// Pøístup ke sdíleným prostøedkùm
g_promenna = 173;

// Odemknutí mutexu
if(SDL_mutexV(g_mutex) == -1)
{
	fprintf(stderr, "Nelze zamknout mutex\n");
	// Vhodná reakce
}

// Zru¹ení mutexu (deinicializace)
SDL_DestroyMutex(g_mutex);
</pre>

<p>Z pøíkladu je vidìt, ¾e i obyèejné pøiøazení do promìnné, ke které pøistupují dvì odli¹ná vlákna, musí být ohlídáno mutexem. Nechtìjte se dostat do situace, kdy musíte odladit vícevláknový program, který z neznámého dùvodu a poka¾dé na jiném místì záhadnì padá. Nejvìt¹ím problémem je, ¾e bìh vícevláknové aplikace nelze nikdy identicky zopakovat, pozdìj¹í ladìní probíhá na defakto úplnì jiném programu.</p>


<h3>Semafory</h3>

<p>Dal¹í synchronizaèní promìnnou je semafor, v SDL je reprezentován strukturou SDL_sem. Semafory v sobì zahrnují èíslo, které se pøi zamknutí atomicky dekrementuje a pøi odemknutí atomicky inkrementuje. Pokud je hodnota semaforu záporná, bude vlákno pøi zamykání automaticky zablokováno.</p>

<p>Semafor se vytváøí funkcí SDL_CreateSemaphore() a ru¹í SDL_DestroySemaphore(). Jedním ze zpùsobù vyu¾ití poèáteèní hodnoty je specifikace maximálního poètu vláken, které mohou vykonávat urèitou èinnost - aby napøíklad nedo¹lo k pøetí¾ení systému.</p>

<pre>
SDL_sem *SDL_CreateSemaphore(Uint32 initial_value);
void SDL_DestroySemaphore(SDL_sem *sem);
</pre>

<p>Funkce SDL_SemWait() pozastaví vlákno do té doby, ne¾ se hodnota semaforu dostane do kladných hodnot. Po prùchodu funkcí je následnì dekrementována. U druhé uvedené funkce, SDL_SemTryWait(), je èinnost stejná, ale vlákno nebude nikdy zablokováno. Neèeká se na vpu¹tìní, ale místo toho je ihned vrácena konstanta SDL_MUTEX_TIMEDOUT, podle které se programátor rozhoduje, co udìlat dál.</p>

<p>Tøetí varianta reprezentovaná SDL_SemWaitTimeout() je opìt témìø stejná, jako pøede¹lé. Na rozdíl od nich èeká na vpu¹tìní pouze stanovený poèet milisekund a poté opìt vrací konstantu SDL_MUTEX_TIMEDOUT. Dokumentace uvádí, ¾e je na nìkterých platformách implementována cyklem, který ka¾dou milisekundu testuje hodnotu semaforu, co¾ není zrovna efektivní.</p>

<pre>
int SDL_SemWait(SDL_sem *sem);
int SDL_SemTryWait(SDL_sem *sem);
int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout);
</pre>

<p>Po opu¹tìní oblasti, ve které se pøistupuje ke sdíleným prostøedkùm, by se mìla zavolat funkce SDL_SemPost(). Dojde ke zvý¹ení hodnoty semaforu a pøípadnému odblokování nìkterého z èekajících vláken. Podobnì, jako u mutexù, by se mìla v¾dy volat ve dvojici s úspì¹nì provedenými wait funkcemi.</p>

<pre>
int SDL_SemPost(SDL_sem *sem);
</pre>

<p>Hodnotu semaforu lze kdykoli získat funkcí SDL_SemValue(). Nikdy by se v¹ak nemìla pou¾ívat pro rozhodnutí o pøístupu ke sdíleným prostøedkùm, proto¾e se nejedná o atomickou operaci.</p>

<pre>
Uint32 SDL_SemValue(SDL_sem *sem);
</pre>

<p>Jako pøíklad je uveden pokus o zamknutí pomocí SDL_SemTryWait(). Je-li semafor zamknut jiným vláknem, funkce se sice ukonèí ihned, ale kód vlákno ke sdíleným prostøedkùm nepustí.</p>

<pre>
// Pokus o zamknutí
int res = SDL_SemTryWait(my_sem);

// Chyba
if(res == -1)
	return CHYBA_PRI_ZAMYKANI;

// U¾ zamknut jiným vláknem
if(res == SDL_MUTEX_TIMEDOUT)
	return SEMAFOR_ZAMKNUT;

/*
 * Operace se sdílenými prostøedky
 */

// Odblokování
SDL_SemPost(my_sem);
</pre>


<h3>Podmínìné promìnné</h3>

<p>Podmínìné promìnné (anglicky condition variables) jsou reprezentovány strukturou SDL_cond a vytváøejí se funkcí SDL_CreateCond(). Pro jejich zru¹ení slou¾í SDL_DestroyCond(). Díky nim lze implementovat o nìco komplexnìj¹í podmínky øídící vykonávání vláken.</p>

<pre>
SDL_cond *SDL_CreateCond(void);
void SDL_DestroyCond(SDL_cond *cond);
</pre>

<p>Zamykání je v tomto pøípadì o nìco slo¾itìj¹í ne¾ u jiných synchronizaèních prostøedkù. Funkce SDL_CondWait() pøebírá v prvním parametru podmínìnou promìnnou a ve druhém libovolný mutex. Ten by mìl být pøed vstupem do funkce zamknutý. Proto¾e je po prùchodu funkcí automaticky odemknut, je na programátorovi, aby ho opìtovnì uzamknul. Èekání druhé uvedené funkce je èasovì omezené, po vypr¹ení intervalu vrací konstantu SDL_MUTEX_TIMEDOUT.</p>

<pre>
int SDL_CondWait(SDL_cond *cond, SDL_mutex *mut);
int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms);
</pre>

<p>Voláním funkce SDL_CondSignal() se restartuje jedno z vláken, která èekají na na odemknutí podmínìné promìnné a v pøípadì SDL_CondBroadcast() jsou restartovány v¹echna.</p>

<pre>
int SDL_CondSignal(SDL_cond *cond);
int SDL_CondBroadcast(SDL_cond *cond);
</pre>


<h2>Literatura</h2>

<p>Jak u¾ jsem zmínil v prùbìhu textu, je tento èlánek spí¹e úvodem do problematiky vícevláknového programování. Pokud vás zaujala, v knihách uvedených ní¾e, mù¾ete najít mnohem podrobnìj¹í informace.</p>

<p>Mark Mitchell, Jeffrey Oldham, Alex Samuel: Pokroèilé programování v operaèním systému Linux (procesùm a vláknùm se vìnují kapitoly 3, 4 a 5). Anglickou verzi této knihy lze také stáhnout z webu <a href="http://www.advancedlinuxprogramming.com/">http://www.advancedlinuxprogramming.com/</a>, je ¹íøena pod licencí Open Publication License.</p>

<p>Jeffrey Richter: Windows pro pokroèilé a experty. Jedná se o trochu star¹í knihu, která se sice vìnuje je¹tì Win 95/NT, ale rozhodnì stojí za to. Mimochodem, u¾ ji asi nekoupíte, zkusil bych spí¹e nìjakou knihovnu.</p>


<h2>Ukázkové programy</h2>

<p>Moc se omlouvám, ale v tomto dílu ¾ádný ukázkový program nebude. Je to hlavnì proto, ¾e s multithreadingem nemám moc praktických zku¹eností a netroufám si napsat ¾ádný vìt¹í program, který by stál za to.</p>

<p>Druhým dùvodem a v tuto chvíli o nìco podstatnìj¹ím je, ¾e momentálnì nemám na disku ¾ádný operaèní systém a èlánek dopisuji z live CD Slaxu, kde není ani gcc nato¾ SDL. Pùvodnì jsem si myslel, ¾e mi 'strýèek' Debian spadl, ale po neúspì¹ných pokusech s novou instalací (Debian Stable, Ubuntu, Gentoo) odhalil memtest problémy s RAM. Ach jo... :-(</p>


<h2>Download</h2>

<p><ul>
<li><a href="sdl_22.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Seriál se pomalu chýlí ke konci. Pøí¹tì se je¹tì podíváme na práci se SDL_RWops, co¾ je technika, kterou SDL poskytuje pro abstrakci nad vstupními daty a zbude-li místo, zkusím sepsat v¹echno, na co jsem bìhem psaní seriálu zapomnìl.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 17.07.2005</div>

</body>
</html>
