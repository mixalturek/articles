<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (15)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (15)</h1>

<p class="perex">V dne¹ním dílu o knihovnì SDL dokonèíme popis událostního systému. Budeme se mimo jiné vìnovat zmìnám velikosti okna, jeho aktivacím a deaktivacím, posílání u¾ivatelských zpráv a dal¹ím vìcem, které je¹tì zbývá probrat.</p>


<h2>Ukonèení aplikace</h2>

<p>Po¾adavek na ukonèení posílá operaèní systém/správce oken, kdy¾ z nìjakého dùvodu po¾aduje po aplikaci, aby se ukonèila. Ve vìt¹inì pøípadù se jedná o pokus u¾ivatele zavøít okno programu.</p>

<p>Dal¹ím dùvodem pro vlo¾ení SDL_QUIT do fronty mù¾e být pøíchozí signál od operaèního systému. SDL_Init() v¾dy instaluje handlery pro SIGINT (pøeru¹ení klávesnicí) a SIGTERM (po¾adavek na ukonèení od operaèního systému). Pokud programátor handlery pro tyto signály nevytvoøí, jsou pou¾ity defaultní, které generují událost SDL_QUIT. U ní nelze ¾ádným zpùsobem zjistit, z jakého dùvodu byla poslána, ale nastavením handleru mù¾e být standardní chování pøepsáno.</p>

<p>SDL_QUIT je nejjednodu¹¹í ze v¹ech událostí. V SDL_Event sice existuje objekt struktury SDL_QuitEvent (event.quit), ten v¹ak neobsahuje jinou informaci, ne¾ je typ události.</p>

<pre>
typedef struct
{
	Uint8 type
} SDL_QuitEvent;
</pre>

<p>Nejvhodnìj¹í reakcí na tuto zprávu je buï rovnou ukonèit aplikaci, nebo, ve výjimeèných pøípadech, zaèít s ukonèovacím dialogem, jako je zobrazení hlavního menu hry a podobnì.</p>

<p>Kdykoli v programu se lze pomocí SDL_QuitRequested() zeptat, jestli náhodou nebyl vznesen po¾adavek na ukonèení, v takovém pøípadì vrátí toto makro nenulovou hodnotu.</p>


<h2>Zmìna velikosti okna</h2>

<p>Zmìnu velikosti okna oznamuje SDL posláním zprávy SDL_VIDEORESIZE, která v event.resize, objektu struktury SDL_ResizeEvent, poskytuje novou ¹íøku a vý¹ku okna.</p>

<pre>
typedef struct
{
	Uint8 type;
	int w, h;
} SDL_ResizeEvent;
</pre>

<p>V reakci na událost by mìla být zavolána funkce SDL_SetVideoMode() (viz <a href="sdl_04.html">4. díl</a>), která aktualizuje velikost klientské oblasti okna, do ní¾ program kreslí.</p>

<p>Pozn.: V MS Windows s OpenGL zpùsobuje SDL_SetVideoMode() jisté problémy, viz <a href="sdl_08.html">8. díl</a> vìnovaný OpenGL a SDL.</p>

<p>Pokud chceme z nìjakého dùvodu zakázat u¾ivateli, aby mohl zmìnit velikost okna, není nic snaz¹ího, ne¾ NEpøedat funkci SDL_SetVideoMode() parametr SDL_RESIZABLE.</p>


<h2>Po¾adavek na pøekreslení</h2>

<p>Událostí SDL_VIDEOEXPOSE oznamuje SDL programu, ¾e je z nìjakého dùvodu nutné pøekreslit obsah okna. Tento stav mù¾e nastat, kdy¾ je okno modifikováno vnì aplikace, obvykle správcem oken. Objekt struktury SDL_ExposeEvent, jen¾ lze najít v event.expose, neobsahuje kromì typu ¾ádné parametry.</p>

<pre>
typedef struct
{
	Uint8 type
} SDL_ExposeEvent;
</pre>


<h2>(De)aktivace okna</h2>

<p>Pøijde-li aplikaci zpráva SDL_ACTIVEEVENT, znamená to, ¾e u¾ivatel okno buï aktivoval nebo deaktivoval (napø. minimalizace). Specifické informace se pak hledají v event.active.</p>

<pre>
typedef struct
{
	Uint8 type;
	Uint8 gain;
	Uint8 state;
} SDL_ActiveEvent;
</pre>

<p>Promìnná gain má v pøípadì deaktivace nulovou hodnotu, jednièka naopak oznaèuje aktivaci. State mù¾e být nastaveno celkem na tøi rùzné konstanty: SDL_APPMOUSEFOCUS, SDL_APPINPUTFOCUS a SDL_APPACTIVE.</p>

<p>První z nich vyjadøuje, ¾e okno ztratilo/získalo fokus my¹i, co¾ defakto znamená, ¾e my¹ opustila nebo dosáhla oblasti okna. U druhé je pøedmìtem zájmu klávesnice. Tento parametr obyèejnì vyjadøuje, ¾e se jiná aplikace stala aktivní. Koneènì poslední mo¾nost oznamuje minimalizaci, respektive obnovení minimalizovaného okna.</p>

<p>Podobným stylem, jako se pøistupovalo ke klávesnici nebo my¹i, se lze dotazovat i na stav okna. Funkce SDL_GetAppState() vrací kombinaci tøí, vý¹e zmínìných, symbolických konstant.</p>

<pre>
Uint8 SDL_GetAppState(void);
</pre>

<p>Deaktivaèní událost se hodí napøíklad v pøípadì, kdy kvùli animacím periodicky pøekreslujeme scénu. Je zbyteèné, aby se tato èinnost provádìla i tehdy, je-li okno minimalizované, proto¾e u¾ivatel nemá ¹anci cokoli zahlédnout.</p>

<p>Zachytí-li aplikace v pøíkladu ní¾e minimalizaci okna (událost SDL_ACTIVEEVENT, state obsahuje SDL_APPACTIVE a gain je nulový), je zavolána funkce SDL_WaitEvent(), která uspí program. Parametr NULL v tomto pøípadì øíká, ¾e nechceme, aby byla událost, je¾ probudí aplikaci, odstranìna z fronty.</p>

<pre>
// Zpracování událostí
case SDL_ACTIVEEVENT:
	if(event.active.state &amp; SDL_APPACTIVE)
	{
		if(event.active.gain == 0)
		{
			SDL_WaitEvent(NULL);
		}
	}
	break;
</pre>

<p>Tento kód v¹ak nemusí fungovat v¾dy! Je to zpùsobeno tím, ¾e ve frontì mù¾e být za právì zpracovávanou událostí je¹tì nìjaká dal¹í, která zpùsobí okam¾ité ukonèení SDL_WaitEvent() a opìtovné spu¹tìní programu.</p>

<p>Øe¹ení mù¾e spoèívat v pøesunutí SDL_WaitEvent() mimo událostní smyèku do podmínky tøeba if(wait), kde wait je bool promìnná nastavená na true na stejném místì, na kterém se v tuto chvíli nachází SDL_WaitEvent(). Funkce se tedy spustí a¾ tehdy, máme-li jistotu, ¾e je fronta prázdná.</p>

<p>Mimochodem, dal¹í dùle¾itou podmínkou, aby se dala aplikace uspat, je vypnutí v¹ech systémových èasovaèù - generují zprávy, které by opìt vedly k pøedèasnému probuzení.</p>


<h2>U¾ivatelské události</h2>

<p>Pamatujete, jak jsme v <a href="sdl_11.html">11. díle</a> popisovali funkci SDL_PushEvent()? Øekli jsme si, ¾e uvnitø aplikace se neposílají standardní, ale vìt¹inou tzv. u¾ivatelské události. Pøi jejich pou¾ívání musí program zajistit nejen jejich zpracování, ale také posílání.</p>

<pre>
typedef struct
{
	Uint8 type;
	int code;
	void *data1;
	void *data2;
} SDL_UserEvent;
</pre>

<p>Parametr type mù¾e nabývat hodnot z rozsahu SDL_USEREVENT a¾ SDL_NUMEVENTS-1. Vzhledem k tomu, ¾e má SDL_USEREVENT hodnotu 24 a celkový poèet je 32, není poèet událostí nijak závratný. Øe¹ením mù¾e být druhý parametr, jen¾ mù¾e být pou¾it, stejnì jako v¹e u u¾ivatelských událostí, naprosto libovolným zpùsobem - èili i na rozli¹ení &quot;typu&quot; události. Tímto malým podvodem se jejich poèet právì rozrostl, v pøípadì 32 bitového procesoru, z pùvodních osmi na nìkolik desítek miliard (pøesnì 8 * 2<sup>32</sup>).</p>

<p>Díky tomu, ¾e jsou dal¹í dva parametry datového typu ukazatelù na void, mohou se spolu s událostmi posílat naprosto libovolná data (resp. ukazatele na nì), jejich velikost navíc není omezena.</p>

<p>V následujícím pøíkladu po¹leme funkci zpracovávající události testovací zprávu. Pro jednoduchost bude bez parametrù.</p>

<pre>
// Nejlépe do vyhrazeného hlavièkového souboru
#define USR_EVT_MOJE_UDALOST 0

// Kdekoli v kódu
SDL_Event event;

event.type = SDL_USEREVENT;
event.user.code = USR_EVT_MOJE_UDALOST;
event.user.data1 = NULL;// Bez parametrù
event.user.data2 = NULL;
SDL_PushEvent(&amp;event);
</pre>

<p>Pozn.: Doporuèuji vytvoøit si nìjaký speciální hlavièkový soubor, ve kterém se budou uchovávat jména/kódy v¹ech u¾ivatelských událostí hezky pøehlednì na jednom místì. U vìt¹ích projektù, zvlá¹» kdy¾ se na vývoji podílí více lidí, se pak nedostanete do situace, kdy si zaènete øíkat 'Ne, událost èíslo 15 u¾ bude urèitì zabraná, ale 735689 by je¹tì mohla být volná ;-)'.</p>

<p>U¾ivatelská událost se dá o¹etøit úplnì stejnì, jako kterákoli jiná, podrobnosti se tentokrát nacházejí v podobjektu event.user.</p>

<pre>
// Zpracování událostí
case SDL_USEREVENT:
	switch(event.user.code)
	{
	case USR_EVT_MOJE_UDALOST:
		// K parametrùm by se pøistupovalo takto:
		// param1 = (pretypovani*)event.user.data1;
		// param2 = (pretypovani*)event.user.data2;
		NecoUdelej();
		break;

	default:
		break;
	}
	break;
</pre>


<h2>Systémovì závislé události</h2>

<p>Poslední typ událostí, které je¹tì zbývá probrat, jsou události závislé na systému, v nìm¾ aplikace bì¾í. Program samozøejmì nikdy nedostává zprávy, které se bì¾nì pou¾ívají v SDL, ale jen jejich ekvivalenty poskytované daným systémem.</p>

<p>Napøíklad po¹le-li MS Windows zprávu WM_KEY_DOWN, SDL ji pøelo¾í na SDL_KEYDOWN a umístí do fronty zpráv. U jiného systému se událost stisku klávesy mù¾e jmenovat úplnì jinak, ale díky SDL program pracuje v¾dy jen s obecnou zprávou SDL_KEYDOWN.</p>

<p>Pro události, které nemají svùj ekvivalent, poskytuje SDL speciální událost SDL_SYSWMEVENT, která je v sobì v¹echny zahrnuje. Podrobnosti se hledají v event.syswm. Vkládání tìchto událostí do fronty je standardnì vypnuté, zapnutí je umo¾nìno klasicky pomocí funkce SDL_EventState().</p>

<pre>
typedef struct
{
	Uint8 type;
	SDL_SysWMmsg *msg;
} SDL_SysWMEvent;
</pre>

<p>Jediným parametrem události je ukazatel na objekt struktury SDL_SysWMmsg. Ta je pomocí komplikovaných pøíkazù preprocesoru deklarována v hlavièkovém souboru SDL_syswm.h v¾dy pro daný systém, na nìm¾ se program právì kompiluje. Napøíklad pro zprávy MS Windows vypadá deklarace struktury následovnì (Win32 programátorùm jistì povìdomá).</p>

<pre>
struct SDL_SysWMmsg
{
	SDL_version version;
	HWND hwnd;
	UINT msg;
	WPARAM wParam;
	LPARAM lParam;
};
</pre>

<p>Systémovým událostem dal¹í prostor vìnován nebude. Tyto techniky jsou pøedev¹ím naprosto nepøenositelné, u kódu napsaného pro MS Windows nelze pøedpokládat, nato¾ ani doufat, ¾e pùjde pod Linuxem a to samé samozøejmì platí i opaèným smìrem.</p>

<p>SDL bì¾í na desítkách systémù, zkusíte-li implementovat danou funkènost pro ka¾dý zvlá¹», vìt¹inou skonèíte se dvìma nebo maximálnì se tøemi nejpou¾ívanìj¹ími, které jsou pro vás dostupné, a ostatní jednodu¹e podporovány nebudou.</p>

<p>Navíc, pokud se pustíte do vyu¾ívání událostí závislých na systému, pravdìpodobnì máte dostatek znalostí, ¾e to zvládnete i bez pomoci tohoto seriálu...</p>


<h2>Ukázkové programy</h2>

<h3>Menu</h3>

<p>Ukázkový program demonstruje vytvoøení jednoduchého menu, které je zapouzdøené do speciální tøídy (resp. do dvou). Rodièovské QMenu se stará o operace, jako je vkládání polo¾ek, pohyb v menu, posílání událostí apod., a potomek QSDLMenu o vykreslování. Nechcete-li pou¾ít pro vykreslování SDL/SDL_ttf, ale napøíklad OpenGL, není nic snaz¹ího ne¾ naprogramovat dal¹ího potomka, základní funkènost zùstává zachována v QMenu.</p>

<p>Pozn.: To písmenko Q na zaèátku, oznaèuje tøídy z jedné mé knihovnièky (zatím soukromá, neustále spousta zmìn). Tímto programem jsem defakto zaplácl dvì mouchy jednou ranou - ukázkový program ke èlánku a menu do semestrální práce z C++ ;-)</p>

<p>Co se týèe funkcí programu, tak jednotlivé polo¾ky menu umo¾òují výbìr obrázku na pozadí, skrytí menu a ukonèení aplikace. Mezi polo¾kami se dá pohybovat ¹ipkami a výbìr zprostøedkovává klávesa enter. Po jejím stisknutí generuje tøída u¾ivatelskou událost, její¾ zpracování je u¾ na aplikaci.</p>

<p>Zdrojový kód se zvýraznìním syntaxe: <a href="./src/sdl_15_a.html">aplikace</a>, <a href="./src/sdl_15_a_qmenu_h.html">qmenu.h</a>, <a href="./src/sdl_15_a_qmenu_cpp.html">qmenu.cpp</a>, <a href="./src/sdl_15_a_qsdlmenu_h.html">qsdlmenu.h</a>, <a href="./src/sdl_15_a_qsdlmenu_cpp.html">qsdlmenu.cpp</a></p></p>

<div class="img"><img src="./data/15_prog_a.png" width="322" height="259" alt="Menu" /></div>


<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_15_a.tar.gz">Pøíklad: Menu</a></li>
<li><a href="sdl_15.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Pøí¹tì se budeme zabývat timery, FPS regulací rychlosti a v podstatì v¹emu s tematikou èasu.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 03.05.2005</div>

</body>
</html>
