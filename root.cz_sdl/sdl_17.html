<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (17)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (17)</h1>

<p class="perex">V dne¹ním díle o knihovnì SDL zaèneme nový tematický celek, budou jím zvuky a hudba, které pøinesou konec v¹em tichým aplikacím.</p>


<h2>Zvuky v poèítaèi</h2>

<p>Asi to u¾ budete znát, ale pro jistotu uvedu alespoò velice struèný úvod do zpracování audia poèítaèem. Zvuk je ve své podstatì vlnìní - analogová velièina, která se na digitální signál pøevádí tzv. vzorkováním. V¾dy po uplynutí pøedem stanoveného èasového intervalu se odebere &quot;vzorek&quot; zvuku, co¾ je èíslo udávající hodnotu signálu v daném okam¾iku, a ulo¾í se do pamìti.</p>

<p>Pøi posílání posloupnosti vzorkù na zvukovou kartu jsou vytváøeny aproximace pùvodních zvukových vln. Výslednou kvalitu tedy ovlivòuje jak frekvence, se kterou byly vzorky odebrány, tak jejich velikost. Bì¾nì podporovaným audio formátem je 16 bitový vzorek na 22 kHz, co¾ je kompromis mezi výslednou kvalitou a velikostí potøebné pamìti pro ulo¾ení.</p>


<h2>SDL a audio</h2>

<p>Knihovna SDL poskytuje nízkoúrovòový pøístup pro práci s audiem navr¾ený jako základ pro implementaci softwarového zvukového mixeru. Na první pohled by se mohlo zdát, ¾e si musí naprostou vìt¹inu funkènosti napsat programátor sám, nicménì je mo¾né pou¾ívat ji¾ hotový mixer v podobì roz¹iøující knihovny SDL_mixer, který odstraní vìt¹inu námahy.</p>

<p>Pokud tedy z nìjakého dùvodu potøebujete nízkoúrovòový pøístup, zvolte si samotné SDL, a pokud preferujete jednodu¹e volatelné funkce, v¾dy mù¾ete jít cestou SDL_mixeru. My se budeme vìnovat obìma zpùsobùm. Zaèneme funkcemi, které poskytuje SDL.</p>

<p>Podobnì, jako u grafiky, i zvukù lze zvolit ovladaè, který bude zprostøedkovávat pøehrávání. Jejich dostupnost je závislá pøedev¹ím na nainstalování v systému a pak také konfiguraèními volbami pøi kompilaci SDL.</p>

<p>Zvolení konkrétního ovladaèe se dá provést pøiøazením jména po¾adovaného ovladaèe do systémové promìnné SDL_AUDIODRIVER, o v¹echny podrobnosti se postará SDL. V Linuxu jsou dostupné napøíklad dsp, dma, esd, artsc, ve Win32 dsound a waveout.</p>

<p>V bì¾ící aplikaci se dá jméno aktuálnì pou¾ívaného driveru zjistit voláním funkce SDL_AudioDriverName(). Pøedává se jí alokovaná pamì», do které se má informace ulo¾it, a proti pøeteèení také její velikost.</p>

<pre>
char *SDL_AudioDriverName(char *namebuf, int maxlen);
</pre>

<p>Pøedpokladem pro to, aby ¹ly v SDL aplikaci zvuky vùbec pou¾ívat, je pøedání symbolické konstanty SDL_INIT_AUDIO do inicializaèní funkce SDL_Init(). Pak je samozøejmì nutné nahrát do aplikace nìjaké zvuky a pøípadnì je zkonvertovat do po¾adovaného formátu. Teprve potom se mù¾e pøistoupit k otevøení audio zaøízení a samotnému pøehrávání.</p>

<p>Men¹í zvlá¹tností oproti jiným knihovnám je, ¾e se musí definovat tzv. callback funkce, kterou bude SDL volat poka¾dé, kdy¾ zvukové kartì dojdou data a bude nutné poslat do streamu nová data.</p>


<h2>Struktura SDL_AudioSpec</h2>

<p>Tato struktura se pou¾ívá ke specifikaci formátu audia, pou¾ívá se pøedev¹ím pøi otevírání zaøízení a také pøi nahrávání zvukù a jejich konverzích na po¾adovaný formát.</p>

<pre>
typedef struct
{
	int freq;
	Uint16 format;
	Uint8 channels;
	Uint16 samples;
	Uint8 silence;
	Uint32 size;
	void (*callback)(void *userdata, Uint8 *stream, int len);
	void *userdata;
} SDL_AudioSpec;
</pre>

<p>Atribut freq udává poèet vzorkù za sekundu (èili frekvenci vzorkování), bì¾nými hodnotami jsou 11025, 22050 a 44100. Format specifikuje formát audio dat, mù¾e nabývat hodnot nìkolika symbolických konstant (viz SDL manuál), které urèují, zda je hodnota vzorkù osmi nebo ¹estnácti bitová, znaménková/bezznaménková apod. Channels udává poèet oddìlených zvukových kanálù, jednièka oznaèuje mono a dvojka stereo.</p>

<p>Promìnná samples ukládá velikost bufferu v poètu vzorkù. Toto èíslo by mìlo být mocninou dvou a mù¾e být audio ovladaèem upraveno na pro hardware vhodnìj¹í hodnotu. Vìt¹inou se volí z rozmezí od 512 do 8192 v závislosti na rychlosti procesoru. Ni¾¹í hodnoty mají krat¹í reakèní èas, ale mohou zpùsobit podteèení v pøípadì, ¾e zaneprázdnìná aplikace nestíhá plnit buffer. Stereo vzorek se skládá z obou kanálù v poøadí levý-pravý a jejich poèet je vzta¾en k èasu podle vzorce ms = (poèet vzorkù * 1000) / frekvence.</p>

<p>Silence a size jsou definovány automaticky. V prvním pøípadì se jedná o hodnotu ulo¾enou v bufferu, která reprezentuje ticho a v druhém jeho velikost v bytech.</p>

<p>Callback pøedstavuje ukazatel na funkci, kterou SDL volá, kdy¾ je audio zaøízení pøipraveno pøijmout nová data. Pøedává se jí ukazatel na buffer/stream, jeho¾ délka se rovná len. Userdata je libovolný ukazatel na dodateèná data.</p>

<pre>
void callback(void *userdata, Uint8 *stream, int len);
</pre>

<p>Vzhledem k tomu, ¾e plnìní bufferu vìt¹inou bì¾í v oddìleném vláknu, mìl by být pøístup k datovým strukturám chránìn pomocí dvojice SDL_LockAudio() a SDL_UnlockAudio(). Je zaruèeno, ¾e po locknutí a¾ do unlocku nebude callback volána a v ¾ádném pøípadì by naopak nemìly být pou¾ity v callback funkci.</p>

<pre>
void SDL_LockAudio(void);
void SDL_UnlockAudio(void);
</pre>


<h2>Otevøení audio zaøízení</h2>

<p>Audio zaøízení se otevírá pomocí SDL_OpenAudio(), kterému se v prvním parametru pøedává po¾adovaný formát. Funkce se pokusí tuto konfiguraci najít a výsledek hledání ulo¾í do obtained, které se tak stává pracovní konfigurací. Ta mù¾e být následnì pou¾ita napøíklad pro konverzi v¹ech zvukù do hardwarového formátu. V pøípadì úspìchu je vrácena nula, jinak -1.</p>

<pre>
int SDL_OpenAudio(SDL_AudioSpec *desired,
		SDL_AudioSpec *obtained);
</pre>

<p>Bylo-li obtained volajícím nastaveno na NULL, budou se, v pøípadì nedostupnosti po¾adovaného formátu, provádìt automatické realtimové konverze do formátu podporovaného hardwarem.</p>

<p>Aby se mohly bezpeènì inicializovat data pro callback funkci plnící buffer, je po otevøení audio implicitinì pozastaveno. Spu¹tìní zvukového výstupu se docílí zavoláním SDL_PauseAudio(0).</p>

<pre>
void SDL_PauseAudio(int pause_on);
</pre>

<p>Na aktuální stav se lze dotázat funkcí SDL_GetAudioStatus(), která vrací výètový typ obsahující SDL_AUDIO_STOPPED, SDL_AUDIO_PAUSED nebo SDL_AUDIO_PLAYING.</p>

<pre>
SDL_audiostatus SDL_GetAudioStatus(void);
</pre>

<p>Po skonèení práce s audiem by se nemìlo zapomenout na jeho deinicializaci.</p>

<pre>
void SDL_CloseAudio(void);
</pre>

<p>Otevøení audio zaøízení by mohlo vypadat napøíklad takto.</p>

<pre>
// Prototyp callback funkce
void AudioCallback(void *userdata, Uint8 *stream, int len);

// Inicializace
SDL_AudioSpec desired, obtained;

desired.freq = 22050;		// FM Rádio kvalita
desired.format = AUDIO_S16LSB;	// 16-bit signed audio
desired.channels = 1;		// Mono
desired.samples = 8192;		// Velikost bufferu
desired.callback = AudioCallback;// Ukazatel na callback
desired.userdata = NULL;	// ®ádná u¾ivatelská data

// Otevøe audio zaøízení
if(SDL_OpenAudio(&amp;desired, &amp;obtained) == -1)
{
	fprintf(stderr, "Unable to open audio: %s\n",
			SDL_GetError());
	return false;
}

// Pøíprava callbacku na hraní
// Napøíklad loading v¹ech zvukù, jejich konverze apod.
// Obtained obsahuje aktuální konfiguraci

// Spustí zvukový výstup
SDL_PauseAudio(0);

// Konec aplikace
SDL_CloseAudio();
</pre>


<h2>Nahrávání zvukù</h2>

<p>Samotné SDL umí nahrávat pouze .WAV formát souborù, který vzhledem ke své velikosti není pro praktické pou¾ití zrovna vhodný. V praxi se proto pro loading zvukù pou¾ívají roz¹iøující knihovny. Napøíklad SDL_sound nebo SDL_mixer si umí poradit i s .MID, .MP3, .OGG a dal¹ími bì¾nì pou¾ívanými formáty.</p>

<pre>
SDL_AudioSpec *SDL_LoadWAV(const char *file,
		SDL_AudioSpec *spec,
		Uint8 **audio_buf,
		Uint32 *audio_len);
</pre>

<p>První parametr funkce SDL_LoadWAV() pøedstavuje diskovou cestu k souboru se zvukem, na adresu spec bude ulo¾en formát nahraných audio dat. Samotná data se ulo¾í do automaticky alokované pamìti, její¾ adresa bude spolu s délkou pøedána zpìt v posledních dvou parametrech.</p>

<p>Funkce vrátí NULL, pokud nelze soubor otevøít, pou¾ívá nepodporovaný formát nebo je po¹kozen. Typ chyby se dá zjistit následným SDL_GetError().</p>

<p>Po skonèení práce se zvukem je v¾dy nutné pomocí SDL_FreeWAV() uvolnit alokovaná data. </p>

<pre>
void SDL_FreeWAV(Uint8 *audio_buf);
</pre>

<p>Pøíklad nahrání zvuku ze souboru...</p>

<pre>
// Globální promìnné
Uint8 *g_sound_data;	// Ukazatel na data
Uint32 g_sound_len;	// Délka dat

// Napø. inicializace
SDL_AudioSpec spec;	// Formát dat

if(SDL_LoadWAV("test.wav", &spec, &g_sound_data,
		&g_sound_len) == NULL)
{
	fprintf(stderr, "Unable to load test.wav: %s\n",
			SDL_GetError());
	return false;
}

// Úklid
SDL_FreeWAV(g_sound_data);
</pre>


<h2>Mixování zvukù</h2>

<p>SDL poskytuje funkci SDL_MixAudio(), která umí smixovat dva zvuky se stejným formátem. První dva parametry pøedstavují cílový a zdrojový buffer, len je délka v bytech a volume oznaèuje hlasitost. Ta mù¾e nabývat hodnot od nuly do SDL_MIX_MAXVOLUME (definováno jako 128) a je vhodné ji nastavit na maximum.</p>

<pre>
void SDL_MixAudio(Uint8 *dst, Uint8 *src, Uint32 len, int volume);
</pre>


<h2>Plnìní audio bufferu</h2>

<p>Jak u¾ bylo zmínìno na zaèátku, SDL je pøi práci se zvuky velmi nízkoúrovòové, a proto je programátor nucen napsat si i vlastní plnìní audio bufferu. Ukazatel na tuto funkci se pøedává do SDL pøi otevírání audio zaøízení a volání je v podstatì automatické.</p>

<p>Kód pøevezmeme z ukázkového programu, který se dodává spoleènì se SDL (adresáø test). Jeho výsledkem bude zvuk pøehrávaný v nekoneèné smyèce.</p>

<pre>
Uint8	*g_sound_data;	// Ukazatel na data zvuku
Uint32	g_sound_len;	// Délka dat
int	g_sound_pos;	// Pozice pøi pøehrávání

void AudioCallback(void *userdata, Uint8 *stream, int len)
{
	// Ukazatel na èást, kde se má zaèít pøehrávat
	Uint8 *wave_ptr = g_sound_data + g_sound_pos;

	// Délka zvuku do konce
	int wave_left = g_sound_len - g_sound_pos;

	// Zbývající délka je men¹í ne¾ po¾adovaná
	// Cyklus, proto¾e celý zvuk mu¾e být krat¹í
	while(wave_left &lt;= len)
	{
		// Po¹le data na zvukovou kartu
		SDL_MixAudio(stream, wave_ptr, wave_left,
				SDL_MIX_MAXVOLUME);

		// Posune se o právì zapsaná data
		stream += wave_left;
		len -= wave_left;

		// Od zaèátku zvuku
		wave_ptr = g_sound_data;
		wave_left = g_sound_len;
		g_sound_pos = 0;
	}

	// Zbývající èást zvuku je del¹í ne¾ po¾adovaná
	SDL_MixAudio(stream, wave_ptr, len,
			SDL_MIX_MAXVOLUME);
	g_sound_pos += len;
}
</pre>


<h2>Ukázkové programy</h2>

<h3>SDL a audio</h3>

<p>Vìt¹í èást dne¹ního programu se objevila u¾ ve èlánku, jedná se tedy o aplikaci pøehrávající v nekoneèné smyèce zvuk nahraný z .wav souboru. Mezerníkem je mo¾né zvukový výstup doèasnì pozastavit a pomocí +/- se dá mìnit hlasitost. <a href="./src/sdl_17_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>


<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_17_a.tar.gz">Pøíklad: SDL a audio</a></li>
<li><a href="sdl_17.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>V pøí¹tím díle probereme funkce, které SDL poskytuje pro konverzi zvukù do po¾adovaného formátu, nahrávání zvukù pomocí knihovny SDL_sound i z jiných typù souborù ne¾ je .WAV, a pokud zbyde trochu místa, zkusíme nakousnout knihovnu SDL_mixer.</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 16.06.2005</div>

</body>
</html>
