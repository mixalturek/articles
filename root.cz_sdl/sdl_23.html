<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta name="author" content="all: Michal Turek - Woq; WOQ (zavináè) seznam.cz" />
<style type="text/css" media="all">@import "./data/style.css";</style>
<title>SDL: Hry nejen pro Linux (23)</title>
</head>

<body>

<h1>SDL: Hry nejen pro Linux (23)</h1>

<p class="perex">V dne¹ním, závìreèném, díle o knihovnì SDL se pokusím shrnout v¹echny vìci, na které jsem bìhem psaní seriálu pozapomnìl popø. kterým jsem se z dùvodu mé neznalosti nevìnoval pozornost. Mimo jiné se budeme vìnovat SDL_RWops, YUV video overlay, nahrávání sdílených knihoven za bìhu aplikace a promìnným prostøedí.</p>


<h2>SDL_RWops</h2>

<p>SDL_RWops je technika, kterou SDL poskytuje pro naèítání obrázkù a zvukù (obecnì libovolných dat) z pamìti namísto z diskových souborù.</p>

<p>Pokud umíte pou¾ívat napø. nìkterou z knihoven pro komprimaci, díky SDL_RWops je mo¾né importovat obrázky z archivu úplnì stejnì, jako by byly ulo¾eny pøímo na disku. Nebo, jste-li schopni napojit aplikaci k vysílání internetového rádia, naprogramování pøehrávaèe bude otázkou pouhé chvíle. Fantazii se meze opravdu nekladou.

<p>Základní funkcí pro vytvoøení SDL_RWops je SDL_RWFromFile(), která slou¾í pro práci s klasickými soubory. První parametr specifikuje diskovou cestu a druhý oznaèuje mód otevøení analogický parametru standardní funkce fopen() - "r" pro ètení, "w" pro zápis, atd.</p>

<pre>
SDL_RWops *SDL_RWFromFile(const char *file,
			const char *mode);
</pre>

<p>Funkce SDL_RWFromFP() je analogií SDL_RWFromFile(), v prvním parametru pøebírá namísto øetìzce se jménem deskriptor otevøeného souboru. Pokud nebude druhý parametr nulový, SDL soubor po skonèení práce automaticky uzavøe.</p>

<pre>
SDL_RWops *SDL_RWFromFP(FILE *fp, int autoclose);
</pre>

<p>Pozn.: Dokumentace uvádí, ¾e SDL_RWFromFP() není pod Win32 dostupná. Na této platformì údajnì nemohou být soubory otevøené aplikací pou¾ity dynamicky linkovanou knihovnou.</p>

<p>Jádrem SDL_RWops jsou funkce SDL_RWFromMem() a SDL_RWFromConstMem(), které vytváøejí SDL_RWops z dat ulo¾ených v pamìti, resp. v konstantní pamìti. Pøedává se jim ukazatel na tuto pamì» a její velikost.</p>

<pre>
SDL_RWops *SDL_RWFromMem(void *mem, int size);
SDL_RWops *SDL_RWFromConstMem(const void *mem, int size);
</pre>

<p>Funkce SDL_AllocRW() alokuje pamì» pro prázdnou SDL_RWops strukturu a SDL_FreeRW() slou¾í pro její uvolnìní. Pou¾ívají se témìø výhradnì pøi vytváøení SDL_RWops z nìjakého nestandardního zdroje. V¹echna vnitøní data vráceného objektu se musí inicializovat manuálnì, pøíklad je mo¾né najít v dne¹ním ukázkovém programu, pracuje se v nìm se ZIP archivem.</p>

<pre>
SDL_RWops *SDL_AllocRW(void);
void SDL_FreeRW(SDL_RWops *context);
</pre>

<p>Struktura SDL_RWops obsahuje ve svém nitru atribut rozli¹ující typ obsahu a union ukládající data. Verze stdio slou¾í pro souborové SDL_RWops a mem pro pamì»ové. S poslední polo¾kou, unknown, by se mìlo operovat pøi u¾ivatelské alokaci pomocí vý¹e zmínìné funkce SDL_AllocRW().</p>

<pre>
typedef struct SDL_RWops
{
	Uint32 type;

	union
	{
		struct
		{
			int autoclose;
			FILE *fp;
		} stdio;
		struct
		{
			Uint8 *base;
			Uint8 *here;
			Uint8 *stop;
		} mem;
		struct
		{
			void *data1;
		} unknown;
	} hidden;

	int (*read)(struct SDL_RWops *context, void *ptr, int size, int maxnum);
	int (*write)(struct SDL_RWops *context, const void *ptr, int size, int num);
	int (*seek)(struct SDL_RWops *context, int offset, int whence);
	int (*close)(struct SDL_RWops *context);
} SDL_RWops;
</pre>

<p>Poslední ètyøi polo¾ky struktury jsou ukazatele na funkce, které poskytují pøesuny na jiná místa v pamìti, ètení, zápis a uvolnìní dat. Nemusí se volat pøímo, lze pou¾ít makra ní¾e.</p>

<pre>
#define SDL_RWread(ctx, ptr, size, n)	(ctx)->read(ctx, ptr, size, n)
#define SDL_RWwrite(ctx, ptr, size, n)	(ctx)->write(ctx, ptr, size, n)
#define SDL_RWseek(ctx, offset, whence)	(ctx)->seek(ctx, offset, whence)
#define SDL_RWtell(ctx)			(ctx)->seek(ctx, 0, SEEK_CUR)
#define SDL_RWclose(ctx)		(ctx)->close(ctx)
</pre>

<p>Makra se chovají v podstatì stejnì, jako standardní funkce ze stdio. Parametr ctx je ukazatel na SDL_RWops, ptr adresa bufferu, z/do kterého se ète/zapisuje, size poèet bytù v bloku a n poèet naèítaných/zapisovaných blokù. Návratovou hodnotou je poèet naètených/zapsaných blokù dat nebo -1 pøi chybì. Parametr whence ze SDL_RWseek() mù¾e nabývat konstant SEEK_SET, SEEK_CUR, SEEK_END.</p>

<p>Jenom pro poøádek: poslední z maker, SDL_RWclose(), by mìlo být zavoláno po skonèení práce s libovolným SDL_RWops. Jedinou výjimkou jsou taková SDL_RWops, u kterých bylo po¾ádáno o automatické uzavøení.</p>

<p>Otevøete-li si nìkterý z hlavièkových souborù SDL, zjistíte, ¾e v podstatì v¹echny funkce pracující se soubory pøedstavují pouze aliasy na naèítání ze SDL_RWops. To samé platí pro roz¹iøující knihovny, jako jsou SDL_image, SDL_sound, SDL_ttf a dal¹í. Napøíklad SDL_LoadBMP() je pouze souborová specializace SDL_LoadBMP_RW().</p>

<pre>
SDL_Surface *SDL_LoadBMP_RW(SDL_RWops *src, int freesrc);

#define SDL_LoadBMP(file) \
	SDL_LoadBMP_RW(SDL_RWFromFile(file, "rb"), 1)
</pre>

<p>Vypisovat seznam v¹ech tìchto funkcí je v podstatì zbyteèné. Vìt¹inou by mìlo staèit pøidat ke jménu pøíponu '_RW' a místo øetìzce se jménem pøedat ukazatel na SDL_RWops. Pokud nebude tato technika úspì¹ná, v nìkterém z hlavièkových souborù lze v¾dy najít pøesnou deklaraci.</p>

<p>Ne¾ se se SDL_RWops úplnì rozlouèíme, nelze neuvést odkaz na <a href="http://www.kekkai.org/roger/sdl/rwops/rwops.html">tento výborný tutoriál</a> (anglicky).</p>


<h2>YUV video overlay</h2>

<p>YUV video overlay je grafická struktura, která poskytuje hardwaru pøímý pøístup do pamìti obrázku. Zjednodu¹enì øeèeno, místo, aby se pøi zobrazování v¹echny pixely zdlouhavì kopírovaly na urèité místo na grafické kartì, program pouze oznámí jejich adresu v pamìti a o nic dal¹ího se nestará. Mnohem vy¹¹í rychlost pøedurèuje pou¾ití u pøehrávání videa, jak je patrné u¾ z názvu.</p>

<pre>
typedef struct
{
	Uint32 format;		// Formát
	int w, h;		// Rozmìry
	int planes;		// Poèet rovin (obyèejnì 1 nebo 3)
	Uint16 *pitches;	// Pole pitch
	Uint8 **pixels;		// Pole ukazatelù na data pro ka¾dou rovinu
	Uint32 hw_overlay:1;	// Hardwarovì akcelerovaný?
} SDL_Overlay;
</pre>

<p>Kromì pixelù jsou v¹echny polo¾ky pouze pro ètení, k tìm se ale mù¾e pøistupovat a¾ po zamknutí struktury. Atribut format mù¾e nabývat následujících hodnot, více informací lze najít na <a href="http://www.webartz.com/fourcc/indexyuv.htm">této stránce</a>.</p>

<pre>
#define SDL_YV12_OVERLAY 0x32315659 // Planar mode: Y + V + U
#define SDL_IYUV_OVERLAY 0x56555949 // Planar mode: Y + U + V
#define SDL_YUY2_OVERLAY 0x32595559 // Packed mode: Y0+U0+Y1+V0
#define SDL_UYVY_OVERLAY 0x59565955 // Packed mode: U0+Y0+V0+Y1
#define SDL_YVYU_OVERLAY 0x55595659 // Packed mode: Y0+V0+Y1+U0
</pre>

<p>Overlay se vytváøí funkcí SDL_CreateYUVOverlay(). Její parametry definují rozmìry, formát a surface, na kterém bude zobrazen. Vzhledem k tomu, ¾e je overlay vytvoøen v hardwaru, bude pøi zobrazení oblast surfacu pod ním pøepsána a její obsah není definován. Pro následné uvolnìní slou¾í SDL_FreeYUVOverlay().</p>

<pre>
SDL_Overlay *SDL_CreateYUVOverlay(int width, int height,
		Uint32 format, SDL_Surface *display);

void SDL_FreeYUVOverlay(SDL_Overlay *overlay);
</pre>

<p>Pøi pøímém pøístupu k pixelùm je v¾dy nutné overlay uzamknout.</p>

<pre>
int SDL_LockYUVOverlay(SDL_Overlay *overlay);
void SDL_UnlockYUVOverlay(SDL_Overlay *overlay);
</pre>

<p>Overlay se zobrazuje funkcí SDL_DisplayYUVOverlay(), pozice a velikost cílové oblasti se specifikuje obdélníkem dstrect. Pokud bude mít overlay jinou velikost ne¾ cílová oblast, bude automaticky roztáhnut (max. 2x). Funkce vrací v pøípadì úspìchu nulu.</p>

<pre>
int SDL_DisplayYUVOverlay(SDL_Overlay *overlay,
			SDL_Rect *dstrect);
</pre>

<p>Pozn.: Z mého výkladu bylo asi poznat, ¾e toho o overlay-ích moc nevím :-(. Nìco málo informací, vèetnì nìkolika odkazù, lze najít v <a href="http://www.root.cz/clanky/sdl-hry-nejen-pro-linux-8/nazory/vse/">diskuzi</a> k osmému dílu, kde se toto téma probíralo.</p>


<h2>Little/big endian</h2>

<p>Hlavièkový soubor SDL_endian.h deklaruje funkce pro práci s daty ve formátech little a big endian, tyto dva pojmy se vztahují k poøadí jednotlivých bytù ve vícebajtových promìnných. Na nìkterých platformách se ukládají dùle¾itìj¹í byty na ni¾¹í adresy a na jiných je tomu právì naopak. Vzhledem k tomu, ¾e je SDL multiplatformní, a tedy dostupné na obou typech systémù, je pøítomnost tìchto funkcí naprosto zásadní.</p>

<p>Aby mohla aplikace jednodu¹e zjistit, na kterém typu systému bì¾í, poskytuje SDL symbolickou konstantu SDL_BYTEORDER, která mù¾e být nastavena buï na SDL_LIL_ENDIAN nebo na SDL_BIG_ENDIAN.</p>

<p>Pou¾íváte-li pro naèítání obrázkù, zvukù a ostatních dat standardní SDL funkce, nemusíte se teoreticky o podobné zále¾itosti vùbec starat. Problémy v¹ak mohou nastat, pokud si pí¹ete vlastní loadery. API je relativnì jednoduché, a proto odkazuji zájemce, vzhledem k místu, na vý¹e zmínìný hlavièkový soubor.</p>


<h2>Promìnné prostøedí</h2>

<p>SDL poskytuje dvojici funkcí SDL_putenv() a SDL_getenv(), které umo¾òují zápis a ètení hodnot do/z promìnných prostøedí. Pøi zápisu se pøedává øetìzec ve formátu &quot;jméno=hodnota&quot;, ètení by mìlo být jasné.</p>

<pre>
int SDL_putenv(const char *variable);
#define putenv(X) SDL_putenv(X)

char *SDL_getenv(const char *name);
#define getenv(X) SDL_getenv(X)
</pre>

<p>V shellu je mo¾né definovat promìnné urèitých názvù, kterými lze zmìnit standardní chování SDL. V tomto seriálu jsme se u¾ setkali se SDL_VIDEODRIVER a SDL_AUDIODRIVER specifikující video a audio ovladaèe, je jich v¹ak mnohem více. Podrobný seznam je mo¾né najít v první sekci SDL dokumentace pod pojmem SDL_envvars.</p>


<h2>Dynamické knihovny</h2>

<p>Vìt¹inou se slu¾by z externích knihoven poskytují aplikaci pøi pøekladu, v SDL je v¹ak mo¾né zpøístupòovat knihovny i za bìhu programu. Dynamická knihovna se nahrává funkcí SDL_LoadObject(), v jediném parametru se jí pøedává øetìzec se jménem a cestou. Pro uvolnìní slou¾í funkce SDL_UnloadObject().</p>

<pre>
void *SDL_LoadObject(const char *sofile);
void SDL_UnloadObject(void *handle);
</pre>

<p>Ukazatel na funkci nacházející se ve sdílené knihovnì je mo¾né získat pomocí SDL_LoadFunction(). Parametry definují handle knihovny, ve které se má hledat, a øetìzec se jménem funkce. Knihovna musí zùstat zavedená do pamìti po celou dobu pou¾ívání, pointer by pøestal být validní.</p>

<pre>
void *SDL_LoadFunction(void *handle, const char *name);
</pre>


<h2>Informace o procesoru</h2>

<p>A je¹tì bonus na závìr: Hlavièkový soubor SDL_cpuinfo.h obsahuje nìkolik funkcí, kterými lze zjistit vlastnosti procesoru v poèítaèi. Co která dìlá si jistì domyslíte sami.</p>

<pre>
SDL_bool SDL_HasRDTSC();
SDL_bool SDL_HasMMX();
SDL_bool SDL_HasMMXExt();
SDL_bool SDL_Has3DNow();
SDL_bool SDL_Has3DNowExt();
SDL_bool SDL_HasSSE();
SDL_bool SDL_HasSSE2();
SDL_bool SDL_HasAltiVec();
</pre>


<h2>Ukázkové programy</h2>

<h3>Obrázky ze ZIP archivu</h3>

<p>Program je modifikací ukázkového pøíkladu ze <a href="sdl_13.html">13. dílu</a>, obrázky se teï naèítají pomocí SDL_RWops ze ZIP archivu, jinak ¾ádná vìt¹í zmìna. Aby ¹el program zkompilovat, musí být v systému nainstalovaná knihovna <a href="http://zziplib.sourceforge.net/">zziplib</a>. Je ¹íøena pod licencí GNU LGPL a pracuje pod nìkolika operaèními systémy vèetnì GNU/Linuxu a MS Windows. <a href="./src/sdl_23_a.html">(zdrojový kód se zvýraznìním syntaxe)</a></p>

<div class="img"><img src="./data/23_prog_a.png" width="322" height="259" alt="Obrázky ze ZIP archivu" /></div>


<h2>Download</h2>

<p><ul>
<li><a href="./src/sdl_23_a.tar.gz">Pøíklad: Obrázky ze ZIP archivu</a></li>
<li><a href="sdl_23.tar.gz">Offline verze èlánku vèetnì v¹ech pøíloh</a></li>
</ul></p>


<h2>Pokraèování</h2>

<p>Jak jsem zmínil na zaèátku, toto je poslední díl na¹eho seriálu o knihovnì SDL. Popravdì zbyly je¹tì dvì témata, která jsem chtìl pùvodnì zaøadit, ale u¾ se jim vìnovat nebudu.</p>

<p>Prvním z nich je roz¹iøující knihovna SDL_net pro implementaci sí»ových her. Bohu¾el jediné, co o ní v souèasné dobì vím, je to, ¾e existuje - na komplexní èlánek docela málo.</p>

<p>Druhým tématem mìla být tvorba GUI. Pro SDL existuje hned nìkolik knihoven na tvorbu tlaèítek, editboxù a podobných vìcí, vìt¹inu z nich lze najít v menu libraries na <a href="http://www.libsdl.org/">libsdl.org</a>. Dal¹í mo¾ností by mohlo být napojení SDL aplikace na GTK nebo QT, popø. minulý týden jsem objevil rychle se rozvíjející C++ knihovnu <a href="http://guichan.sourceforge.net/">Guichan</a> podporující SDL, Allegro a OpenGL (dohromady nebo zvlá¹»). I toto rozsáhlé téma ale nechávám na samostudium.</p>

<p>No, zkusím redaktorùm rootu navrhnout je¹tì jeden, opravdu závìreèný ;-], díl s obsahem a rejstøíkem a pak se se seriálem o SDL koneènì budeme moci rozlouèit...</p>


<div class="autor">Michal Turek - Woq &lt;WOQ (zavináè) seznam.cz&gt;, 24.07.2005</div>

</body>
</html>
