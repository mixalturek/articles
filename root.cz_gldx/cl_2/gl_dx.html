<?xml version="1.0" encoding="ISO-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cz" lang="CZ">
<head>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta http-equiv="content-script-type" content="text/javascript" />
<meta http-equiv="content-style-type" content="text/css" />

<meta name="robots" content="all, follow" />
<meta name="resource-type" content="document" />

<meta name="description" content="Porovnání 3D grafických knihoven OpenGL a Direct3D" />
<meta name="keywords" content="opengl, gl, directx, dx, direct3d, d3d, 3d, grafika" />
<meta name="author" content="all: Michal Turek - Woq; woq (zavináè) seznam.cz" />
<meta name="copyright" content="Copyright (c) 2004 Michal Turek - Woq" /><!-- Ne¾ to vyjde na root.cz :-] -->

<title>OpenGL a Direct3D II.</title>

<link href="style.css" rel="stylesheet" type="text/css" media="all" />
<link href="print.css" rel="stylesheet" type="text/css" media="print" />

</head>
<body>

<div id="text_stranky">

<h1>OpenGL a Direct3D II.</h1>

<p id="uvod">Knihovny jako OpenGL nebo DirectX nejsou pro u¾ivatle a¾ tak dùle¾ité, pro nì jsou to jenom dvì prázdná jména. Mù¾e jim být naprosto jedno, jak program uvnitø funguje. Návrh a hlavnì celková pou¾itelnost API je dùle¾itá primárnì pro programátory. Právì oni s ním pracují, nikdo jiný. V tomto díle budeme porovnávat pøedev¹ím délku kódu, který se musí napsat, aby program nìco udìlal.</p>


<h3>Programátorské hledisko</h3>

<p>Narozdíl od strukturovaného OpenGL je Direct3D objektovì orientované. Jaký je mezi tím rozdíl? V pøípadì OpenGL se na zaèátku programu vytvoøí okno s jeho podporou a pak je mo¾né odkudkoli volat jakékoli OpenGL specifické funkce. V pøípadì Direct3D se musí vytvoøit objekt Direct3D (IDirect3D9), s jeho pomocí zaøízení Direct3D (IDirect3DDevice9) a pøes volání jejich metod programátor pracuje. Objektovì orientované programování sice preferuji také, ale v pøípadì DirectX mi pøipadá hodnì tì¾kopádné - alespoò v porovnání s OpenGL.</p>

<p>Jedním z nejdùle¾itìj¹ích charakteristik jakéhokoli <span title="Application Programming Interface - Aplikaèní programové rozhranní">API</span> je pro programátora délka zdrojového kódu, který musí napsat, aby program nìco udìlal. John Carmack, autor her Quake, uvádí <a href="#literatura">[3]</a>, ¾e kód programu plnící stejnou funkci je v Direct3D i ètyøikrát del¹í ne¾ v OpenGL. Mù¾eme si to bez problémù ovìøit. Z uèebnice Direct3D <a href="#literatura">[1]</a>, str. 180, 181 uvedu jednoduchou renderovací funkci, která na èerném pozadí vykresluje jeden obarvený trojúhelník - bez textur, svìtel èi jakýchkoli maticových operací (translace, rotace). Následnì v¹e pøepí¹i do OpenGL.</p>

<pre>
///////////////////////////////////////////
// Direct3D 9.0
///////////////////////////////////////////

struct VLASTNIVERTEX
{
  FLOAT x, y, z, rhw;
  DWORD barva;
}

void Vykresleni()
{
  VLASTNIVERTEX vrchTrojuhl[] =
  {
    {400.0, 180.0, 0.0, 1.0, D3DCOLOR_XRGB(255,0,0)},
    {500.0, 380.0, 0.0, 1.0, D3DCOLOR_XRGB(0,255,0)},
    {300.0, 380.0, 0.0, 1.0, D3DCOLOR_XRGB(0,0,255)},
  };

  IDirect3DVertexBuffer9* pVertexBuffer = NULL;
  HRESULT hVysledek = g_pZarizeniDirect3D-&gt;CreateVertexBuffer(
    3*sizeof(VLASTNIVERTEX), 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE,
    D3DPOOL_DEFAULT, &amp;pVertexBuffer, NULL);

  if (FAILED(hVysledek))
  {
    DXTRACE_ERR(&quot;Chyba pøi vytv. vertex bufferu.&quot;, hVysledek);
  }

  VOID* pVrcholy;
  hVysledek = pVertexBuffer-&gt;Lock(0, 0, (viod**)&amp;pVrcholy, 0);
  if (FAILED(hVysledek))
  {
    DXTRACE_ERR(&quot;Chyba pøi zamyk. vertex bufferu.&quot;, hVysledek);
  }
  memcpy(pVrcholy, vrchTrojuhl, sizeof(vrchTrojuhl));
  pVertexBuffer-&gt;Unlock();

  g_pZarizeniDirect3D-&gt;Clear(0, NULL, D3DCLEAR_TARGET,
    D3DCOLOR_XRGB(0,0,0), 1.0, 0);
  g_pZarizeniDirect3D-&gt;SetStreamSource(0, pVertexBuffer, 0,
    sizeof(VLASTNI_VERTEX));
  g_pZarizeniDirect3D-&gt;SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
  g_pZarizeniDirect3D-&gt;BeginScene();
  g_pZarizeniDirect3D-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
  g_pZarizeniDirect3D-&gt;EndScene();

  g_pZarizeniDirect3D-&gt;Present(NULL, NULL, NULL, NULL);

  if (pVertexbuffer)
    pVertexBuffer-&gt;Release();
}
</pre>

<p>To samé v OpenGL...</p>

<pre>
///////////////////////////////////////////
// OpenGL
///////////////////////////////////////////

void Vykresleni()
{
	glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();

	glBegin(GL_TRIANGLES);
		glColor3ub(255,0,0); glVertex2i(400,480);
		glColor3ub(0,255,0); glVertex2i(500,380);
		glColor3ub(0,0,255); glVertex2i(300,380);
	glEnd();

	glFlush();
	SDL_GL_SwapBuffers();
}
</pre>

<p>Pozn.: Pøi inicializaci se nesmí definovat perspektiva, ale pravoúhlá projekce (glOrtho()) o rozmìrech 800x600. Funkce glClearColor() se obvykle dává také do inicializace, ve vykreslení je jen kvùli tomu, aby kód plnì odpovídal Direct3D. Pokud provozujete OpenGL ve Win32 API, urèitì pou¾íváte místo SDL_GL_SwapBuffers() funkci SwapBuffers(), SDL má tu výhodu, ¾e lze kód bez vìt¹ích problémù pøená¹et mezi Linuxem, Windows a dal¹ími operaèními systémy.</p>

<div class="okolo_img"><a href="img/rgb_triangle.png"><img src="img/n_rgb_triangle.png" width="200" height="150" alt="RGB trojúhelník" /></a><br />Screenshot OpenGL verze programu</div>

<p>Vrátím se je¹tì k té délce kódu, v pøípadì, ¾e byste je chtìli porovnat èíselnì, pak D3D verze mìla celkem 47 øádkù, 108 slov a 1367 písmen, OpenGL pouze 14 øádkù, 22 slov a 335 písmen. V pomìru to èiní u øádkù 47 / 14 = 3.35, slov 108 / 22 = 4.9 a znakù 1367 / 335 = 4.08 ...ètyønásobná délka kódu tedy plus mínus platí. Zèásti je to i tím, ¾e v D3D sekci byly pou¾ity dlouhé identifikátory, ale za to já nemù¾u, jak jsem napsal vý¹e, jedná se o doslovný pøepis z uèebnice D3D. Dokonce jsem identifikátor vrcholyTrojuhelniku musel zkrátit pouze na vrchTrojuhl, aby se kód ve¹el na øádek.</p>

<pre>
[woq@localhost tmp]$ wc *txt
  47  108 1367 dx.txt
  14   22  335 gl.txt
</pre>

<p>U¾ivatele programu zdrojové kódy absolutnì nezajímají a hlavnì jim nerozumí, tak¾e nepøedpokládám, ¾e jste pøedchozí výpisy zkoumali podrobnì. Jenom tak jimi v rychlosti prolétnìte a zkuste øíci, který z nich je pøehlednìj¹í. Dále si v¹imnìte v D3D sekci kódu øádku if(FAILED(hVysledek)), který se provede pøi chybì ve vytváøení/zamykání vertex bufferu. V OpenGL se toto dìlat nemusí/nelze a to ani pøi pou¾ití vertex arrays, které více odpovídají D3D stylu programování.</p>

<p>Nic podobného, jako je samostatné volání funkcí glVertex*() Direct3D neumí. Vertex arrays jsou sice výhodnìj¹í pøi renderování velkých mno¾ství souvisejících <span title="bodù">vertexù</span>, které jsou v¾dy na konstantní pozici (3D svìty, vý¹kové mapy, 3D modely ap.), proto¾e odpadají ztráty na výkonu pøi mnoha volání funkcí, nicménì u pohyblivých nesouvisejících trojúhelníkù, kde èasto ani nebývá dopøedu znám jejich poèet (typicky èásticové systémy) bývá pou¾ití vertex arrays tì¾kopádné a spí¹e ménì vhodné, navíc se zbyteènì alokuje systémová pamì». V OpenGL si mù¾e programátor zvolit, co pova¾uje za výhodnìj¹í. Pokud je chytrý a pou¾ívá extensiony, mù¾e v¹echna data dokonce ulo¾it v pamìti grafické karty jako tzv. <span title="Vertex Buffer Object">VBO</span>, tím se eliminuje vliv &quot;délky drátù&quot; pøi posílání dat na grafickou kartu. Ale toto pravdìpodobnì jde i v D3D.</p>


<a id="literatura"></a>
<h3>Literatura</h3>

<ul>
<li>[0] Vlastní zku¹enosti s 3D grafikou</li>
<li>[1] Clayton Walnum: Programujeme grafiku v Microsoft&reg; Direct3D (9.0), Computer Press 2004, první vydání, 358 stran</li>
<li>[2] Chip 01/2004, Hardwarový fotorealismus: Mo¾nosti moderních 3D grafických akcelerátorù, str. 96-100)</li>
<li>[3] <a href="http://nehe.opengl.cz/cl_gl_referat.pdf" target="_blank">Daniel Èech: OpenGL - Referát na praktikum z informatiky (PDF)</a> - Opravdu kvalitní text</li>
<li>[4] <a href="http://nehe.opengl.cz/cl_sdl_hry.pdf" target="_blank">Bernard Lidický: Nìkolik poznámek k tvorbì poèítaèových her (PDF)</a> - Vìnuje se pøedev¹ím tématùm, jaké hry programovat a v èem (pøenositelné knihovny Allegro a SDL)</li>
<li>[5] <a href="http://www.root.cz/clanek/2314">Linuxové hry (47): Unreal Tournament 2004</a> - Hlavní impuls pro vznik tohoto èlánku</li>
</ul>


<div>Pro server <a href="http://www.root.cz/">root.cz</a> napsal</div>
<div>Michal Turek - Woq <span class="m">&lt;WOQ (zavináè) seznam.cz&gt;</span></div>

</div><!-- div id="text_stranky" -->

</body>
</html>